[[anchor-configuration-renderstyles]]
== Map styles

Style resources are used to obtain information on how to render geo
objects (mostly features, but also coverages) into maps. The most common
use case is to reference them from a layer configuration, in order to
describe how the layer is to be rendered. This chapter assumes the
reader is familiar with basic SLD/SE terms. The style configurations do
not depend on any other resource.

In contrast to other deegree configurations the style configurations do
not have a custom format. You can use standard SLD or SE documents
(1.0.0 and 1.1.0 are supported), with a couple of deegree specific
extensions, which are described below. Please refer to the
https://www.ogc.org/standard/sld/[SLD] and
https://www.ogc.org/standard/se/[SE] specifications for
reference. Additionally this page contains specific examples below.

In deegree terms, each SLD or SE file will create a _style store_. In
case of an SE file (usually beginning at the FeatureTypeStyle or
CoverageStyle level) the style store only contains one style, in case of
an SLD file the style store may contain multiple styles, each identified
by the layer (only NamedLayers make sense here) and the name of the
style (only UserStyles make sense) when referenced later.

.Style resources define how geo objects are rendered
image::workspace-overview-style.png[Style resources define how geo objects are rendered,scaledwidth=80.0%]

TIP: When defining styles, take note of the log file. Upon startup the log
will warn you about potential problems or errors during parsing, and
upon rendering warnings will be emitted when rendering is unsuccessful
eg. because you had a typo in a geometry property name. When you're
seeing an empty map when expecting a fancy one, check the log before
reporting a bug. deegree will tolerate a lot of syntactical errors in
your style files, but you're more likely to get a good result when your
files validate and you have no warnings in the log.

=== Overview

From the point of view of the Symbology Encoding Standard, there are 5
kinds of symbolizations, which can be present in a map image:

  * *Point symbolizations*
  * *Line symbolizations*
  * *Polygon symbolizations*
  * *Text symbolizations*
  * *Raster symbolizations*

The first 4 symbolizations usually represent vector feature objects.
Raster symbolization is used to visualize raster data. This
documentation chapter describes, how those symbolizations can be
realized using OGC symbology encoding. It will lead from the underlying
basics to some more complex constructions for map visulization.

=== Basics

==== General Layout

The general structure of an SE-Style contains:

[source,xml]
----
<FeatureTypeStyle>
<FeatureTypeName> 
<Rule> 
----

It is constructed like this:

[source,xml]
----
<FeatureTypeStyle xmlns="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc" xmlns:sed="http://www.deegree.org/se" xmlns:deegreeogc="http://www.deegree.org/ogc" xmlns:plan="http://www.deegree.org/plan" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/se http://schemas.opengis.net/se/1.1.0/FeatureStyle.xsd http://www.deegree.org/se https://schemas.deegree.org/core/3.5/se/symbology-1.1.0.xsd">
<FeatureTypeName>plan:yourFeatureType</FeatureTypeName>
    <Rule>
        ...
    </Rule>
</FeatureTypeStyle>
----

TIP: Before you start, always remember that every style is read top-down. So
be aware the second <Rule> will overpaint the first one, the third
overpaints the second and so on

==== Symbolization Rules

Every specific map visualization needs its own symbolization rule. Rules
are defined within the *<Rule>* element. Each rule can consist of at
least one symbolizer. Every rule has its own name and description
elements. The description elements are used to create the legend caption
from it.

Depending on the type of symbolization to create, one of the following
symbolizers can be used:

* <PointSymbolizer>
* <LineSymbolizer>
* <PolygonSymbolizer>
* <TextSymbolizer>
* <RasterSymbolizer>

Symbolizers can have an uom-attribute (units of measure), which
determines the unit of all values set inside the Symbolizer. The
following values for UoM are supported within deegree:

* uom="pixel"
* uom="meter"
* uom="mm"

The default value is "pixel".

Within every symbolizer (except rastersymbolizers), a geometry property
used for the rendering, can be specified with the *<Geometry>* element.
If there is no geometry specified the first geometry property of the
FeatureType will be used.

Each of the (Vector-)Symbolizer-elements has its dimensions, which are
described in more detail below:


* *<LineSymbolizer>* has only one dimension: the <Stroke>-element (to
style the stroke).
* *<PolygonSymbolizer>* has two dimensions: the <Stroke> (to sytle the
stroke of the polygon) and the <Fill>-element (to style the inside of
the polygon).
* *<PointSymbolizer>* can also contain both dimensions: the <Stroke> (to
style the stroke of the point) and the <Fill>-element (to style the
inside of the point).
* *<TextSymbolizer>* has three dimensions: the <Label> (to set the
property, which is to be styled), the <Font> (to style the font) and the
<Fill>-element (to style the inside of the font).


===== Stroke

To describe a <Stroke>, a number of different <SvgParameter> can be
used.

* `name="stroke"` => The stroke (color) is defined by the hex color code
(e.g. black ==> #000000).
* `name="opacity"` => Opacity can be set by a percentage number, written
as decimal (e.g. 0,25 => 25% opacity).
* `name="with"` => Wide or thin, set your stroke-width however you want.
* `name="linecap"` => For linecap (ending) a stroke you can choose the
following types: round, edged, square, butt.
* `name="linejoin"` => Also there are different types of linejoin
possibilities: round, mitre, bevel.
* `name="dasharray"` => The dasharray defines where the stroke is painted
and where not (e.g. "1 1" => - - - ).


[source,xml]
----
<LineSymbolizer uom="meter">
  <Geometry>
    <ogc:PropertyName>layer:position</ogc:PropertyName>
  </Geometry>
  <Stroke>
    <SvgParameter name="stroke">#000000</SvgParameter>
    <SvgParameter name="stroke-opacity">0.5</SvgParameter>
    <SvgParameter name="stroke-width">1</SvgParameter>
    <SvgParameter name="stroke-linecap">round</SvgParameter>
    <SvgParameter name="stroke-linejoin">round</SvgParameter>
    <SvgParameter name="stroke-dasharray">1 1</SvgParameter>
  </Stroke>
</LineSymbolizer>
----

===== Fill

For the visualization of polygons, points and texts, the <Fill> element
can be used additional to styling the <Stroke>. You can set the
following <SvgParameter>:

* name="fill" (color)
* name="fill-opacity"

These two <SvgParameter> are working like those from <Stroke>.

[source,xml]
----
<PolygonSymbolizer uom="meter">
  <Geometry>
    <...>
  </Geometry>
  <Fill>
    <SvgParameter name="fill">#000000</SvgParameter>
    <SvgParameter name="fill-opacity">0.5</SvgParameter>
  </Fill>
  <Stroke>
    <...>
  </Stroke>
</PolygonSymbolizer>
----

===== Font

For the creation of a <TextSymbolizer>, certain parameters for the
displayed text have to be set. Every <TextSymbolizer> needs a <Label> to
be specified. The <Font> to be used for the text symbolization can be
set with <SvgParameter> elements. These are the possible <SvgParameter>:

* `name="font-family"` => Possible types are: e.g. Arial, Times Roman,
Sans-Serif
* `name="font-weight"` => Possible types are: normal, bold, bolder,
lighter
* `name="font-size"` => Possible values are integer values


With a <Fill>-element a color and opacity of the font can be defined.
This method is used to show text which is stored in your database.

[source,xml]
----
<TextSymbolizer uom="meter">
  <Geometry>
    <...>
  </Geometry>
  <Label>
    <ogc:PropertyName>layer:displayedProperty</ogc:PropertyName>
  </Label>
  <Font>
    <SvgParameter name="font-family">Arial</SvgParameter>
    <SvgParameter name="font-family">Sans-Serif</SvgParameter>
    <SvgParameter name="font-weight">bold</SvgParameter>
    <SvgParameter name="font-size">3</SvgParameter>
  </Font>
  <Fill>
    <...>
  </Fill>
</TextSymbolizer>
----

==== Advanced symbolization

There are numerous possibilities for advanced symbolization. This
chapter describes the basic components of advanced map stylings using
symbology encoding.

===== Using Graphics

There are different ways to use graphical symbols as a base for map
symbolizations. <Mark> elements can be used to specify well known
graphics, <ExternalGraphic> elements can be used to have external
graphic files as a base for a symbolization rule.

*Mark*

With Marks it is possible to use wellkown objects for symboliation as
well as user-generated content like SVGs. It is possible to use all of
these for <PointSymbolizer>, <LineSymbolizer> and <PolygonSymbolizer>.

For a <PointSymbolizer> the use of a Mark looks like the following:

[source,xml]
----
<PointSymbolizer uom="meter">
  <Geometry>
    ...
  </Geometry>
  <Graphic>
    <Mark>
      ...
----

For <LineSymbolizer> and <PolygonSymbolizer> it works like this:

[source,xml]
----
<Geometry>
  ...
</Geometry>
<Stroke>
  <GraphicStroke>
    <Graphic>
      <Mark>
        ...
----

The following wellknown objects can be used within Marks:::
  * circle
  * triangle
  * star
  * square
  * x ==> creates a cross

[source,xml]
----
<Mark>
  <WellKnownName>triangle</WellKnownName>
  <Fill>
    ...
  </Fill>
</Mark>
----

Including an SVG graphic within a mark might look like this:

[source,xml]
----
<Mark>
  <OnlineResource xmlns:xlink="http://www.w3.org/1999/xlink" xlink:type="simple"
    xlink:href="/filepath/symbol.svg" />
  <Format>svg</Format>
  <Fill>
    ...
  </Fill>
  <Stroke>
    ...
  </Stroke>
</Mark>
----

*ExternalGraphic*

<ExternalGraphic>-elements can be used to embed graphics, taken from a
graphic-file (e.g. SVGs or PNGs). The <OnlineResource> sub-element gives
the URL of the graphic-file.

TIP: Make sure you don't forget the MIME-type in the <Format>-sub-element
(e.g. "image/svg" or "image/png").

[source,xml]
----
<Graphic>
  <ExternalGraphic>
    <OnlineResource xmlns:xlink="http://www.w3.org/1999/xlink"
      xlink:type="simple" xlink:href="/filepath/symbol.svg" />
    <Format>image/svg</Format>
  </ExternalGraphic>
 <Size>10</Size>
  ...
</Graphic>
----

===== Size

Of course everything has its own <Size>. The size is defined directly
after <Mark> or <ExternalGraphic>.

[source,xml]
----
<Mark>
  <WellKnownName>triangle</WellKnownName>
  <Fill>
    <SvgParameter name="fill">#000000</SvgParameter>
  </Fill>
</Mark>
<Size>3</Size>
----

===== Gap

It is possible to define Gaps for graphics within <LineSymbolizer> or
<PolygonSymbolizer>. For this the <Gap>-element can be used like this:

[source,xml]
----
<GraphicStroke>
  <Graphic>
    <Mark>
      ...
    </Mark>
    ...
  </Graphic>
  <Gap>20</Gap>
</GraphicStroke>l
----

===== Rotation

Symbology Encoding enables the possibility to rotate every graphic
around its center with the <Rotation>-element. This goes from zero to
360 degrees. The rotation is clockwise unless it's negative, then it's
counter-clockwise.

[source,xml]
----
<Graphic>
  <Mark>
    ...
  </Mark>
  <Size>3</Size>
  <Rotation>180</Rotation>
</Graphic>
----

===== Displacement

The <Displacement>-element allows to paint a graphic displaced from his
given position. Negative and positive values are possible. THe
displacement must be set via the X and Y displacement elements.

[source,xml]
----
<Graphic>
  <Mark>
    ...
  </Mark>
  ...
  <Displacement>
    <DisplacementX>5</DisplacementX>
    <DisplacementY>5</DisplacementY>
  </Displacement>
</Graphic>
----

===== Halo

A nice possibility to highlight your font, is the <Halo>-element. The
<Radius>-sub-element defines the size of the border.

[source,xml]
----
<TextSymbolizer uom="meter">
    <Geometry>
        <ogc:PropertyName>xplan:position</ogc:PropertyName>
    </Geometry>
    <Label>
        ...
    </Label>
    <Font>
        ...
    </Font>
    <LabelPlacement>
        ...
    </LabelPlacement>
    <Halo>
        <Radius>1.0</Radius>
        <Fill>
            ...
        </Fill>
    </Halo>
    ...
</TextSymbolizer>
----

=== Using Filters

Within symbolization rules, it is possible to use Filter Encoding
expressions. How construct those expressions is explained within the
<<anchor-configuration-filter>> chapter

=== Basic Examples

==== Point Symbolizer

[source,xml]
----
<FeatureTypeStyle
xmlns="http://www.opengis.net/se"
xmlns:app="http://www.deegree.org/app"
xmlns:ogc="http://www.opengis.net/ogc"
xmlns:sed="http://www.deegree.org/se"
xmlns:deegreeogc="http://www.deegree.org/ogc"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.opengis.net/se http://schemas.opengis.net/se/1.1.0/FeatureStyle.xsd http://www.deegree.org/se https://schemas.deegree.org/core/3.5/se/symbology-1.1.0.xsd">
<Name>Weatherstations</Name>
 <Rule>
    <Name>Weatherstations</Name>
    <Description>
      <Title>Weatherstations in Utah</Title>
    </Description>
    <ogc:Filter>
      <ogc:PropertyIsEqualTo>
        <ogc:PropertyName>SomeProperty</ogc:PropertyName>
        <ogc:Literal>100</ogc:Literal>
      </ogc:PropertyIsEqualTo>
      </ogc:Filter>
      <PointSymbolizer>
        <Graphic>
          <Mark>
            <WellKnownName>square</WellKnownName>
            <Fill>
              <SvgParameter name="fill">#FF0000</SvgParameter>
            </Fill>
            <Stroke>
              <SvgParameter name="stroke">#000000</SvgParameter>
              <SvgParameter name="stroke-width">1</SvgParameter>
            </Stroke>
          </Mark>
          <Size>13</Size>
        </Graphic>
      </PointSymbolizer>
  </Rule> 
</FeatureTypeStyle>
----

==== Line Symbolizer

[source,xml]
----
<FeatureTypeStyle
xmlns="http://www.opengis.net/se"
xmlns:app="http://www.deegree.org/app"
xmlns:ogc="http://www.opengis.net/ogc"
xmlns:sed="http://www.deegree.org/se"
xmlns:deegreeogc="http://www.deegree.org/ogc"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.opengis.net/se http://schemas.opengis.net/se/1.1.0/FeatureStyle.xsd http://www.deegree.org/se https://schemas.deegree.org/core/3.5/se/symbology-1.1.0.xsd">
<Name>Railroads</Name>
  <Rule>
    <Name>Railroads</Name>
    <LineSymbolizer>
      <Stroke>
        <SvgParameter name="stroke">#000000</SvgParameter>
        <SvgParameter name="stroke-opacity">1.0</SvgParameter>
        <SvgParameter name="stroke-width">0.3</SvgParameter>
      </Stroke>
      <PerpendicularOffset>1.5</PerpendicularOffset>
    </LineSymbolizer>
    <LineSymbolizer>
      <Stroke>
        <SvgParameter name="stroke">#ffffff</SvgParameter>
        <SvgParameter name="stroke-opacity">1.0</SvgParameter>
        <SvgParameter name="stroke-width">1.5</SvgParameter>
      </Stroke>
    </LineSymbolizer>
    <LineSymbolizer>
      <Stroke>
        <SvgParameter name="stroke">#000000</SvgParameter>
        <SvgParameter name="stroke-opacity">1.0</SvgParameter>
        <SvgParameter name="stroke-width">0.3</SvgParameter>
      </Stroke>
      <PerpendicularOffset>-1.5</PerpendicularOffset>
    </LineSymbolizer>
  </Rule>    
</FeatureTypeStyle>
----

==== Polygon Symbolizer

[source,xml]
----
<FeatureTypeStyle
 xmlns="http://www.opengis.net/se"
 xmlns:app="http://www.deegree.org/app"
 xmlns:ogc="http://www.opengis.net/ogc"
 xmlns:sed="http://www.deegree.org/se"
 xmlns:deegreeogc="http://www.deegree.org/ogc"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.opengis.net/se http://schemas.opengis.net/se/1.1.0/FeatureStyle.xsd http://www.deegree.org/se https://schemas.deegree.org/core/3.5/se/symbology-1.1.0.xsd">
<Name>LandslideAreas</Name>
  <Rule>
    <Name>LandslideAreas</Name>
    <Description>
      <Title>LandslideAreas</Title>
    </Description>
    <PolygonSymbolizer>
      <Fill>
        <SvgParameter name="fill">#cc3300</SvgParameter>
        <SvgParameter name="fill-opacity">0.3</SvgParameter>
      </Fill>
      <Stroke>
        <SvgParameter name="stroke">#000000</SvgParameter>
        <SvgParameter name="stroke-opacity">1.0</SvgParameter>
        <SvgParameter name="stroke-width">1</SvgParameter>
      </Stroke>
    </PolygonSymbolizer>
  </Rule>
</FeatureTypeStyle>
----

==== Text Symbolizer

[source,xml]
----
<FeatureTypeStyle
 xmlns="http://www.opengis.net/se"
 xmlns:app="http://www.deegree.org/app"
 xmlns:ogc="http://www.opengis.net/ogc"
 xmlns:sed="http://www.deegree.org/se"
 xmlns:deegreeogc="http://www.deegree.org/ogc"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.opengis.net/se http://schemas.opengis.net/se/1.1.0/FeatureStyle.xsd http://www.deegree.org/se https://schemas.deegree.org/core/3.5/se/symbology-1.1.0.xsd">
<Name>Municipalities</Name>
  <Rule>
    <Name>Municipalities</Name>
    <Description>
      <Title>Municipalities</Title>
    </Description>
    <MaxScaleDenominator>200000</MaxScaleDenominator>
    <TextSymbolizer>
      <Label>
        <ogc:PropertyName>app:NAME</ogc:PropertyName>
      </Label>
      <Font>
        <SvgParameter name="font-family">Arial</SvgParameter>
        <SvgParameter name="font-family">Sans-Serif</SvgParameter>
        <SvgParameter name="font-weight">bold</SvgParameter>
        <SvgParameter name="font-size">12</SvgParameter>
      </Font>
      <Halo>
        <Radius>1</Radius>
        <Fill>
          <SvgParameter name="fill-opacity">1.0</SvgParameter>
          <SvgParameter name="fill">#fefdC3</SvgParameter>
        </Fill>
      </Halo>
      <Fill>
        <SvgParameter name="fill">#000000</SvgParameter>
      </Fill>
    </TextSymbolizer>
  </Rule>
</FeatureTypeStyle>
----

=== SLD/SE clarifications

This chapter is meant to clarify deegree's behaviour when using standard
SLD/SE constructs.

==== Perpendicular offset/polygon orientation

For polygon rendering, the orientation is always fixed, and will be
corrected if a feature store yields inconsistent geometries. The outer
ring is always oriented counter clockwise, inner rings are oriented
clockwise.

A positive perpendicular offset setting results in an offset movement in
the outer direction, a negative setting moves the offset into the
interior. For inner rings the effect is flipped (a positive setting
moves into the interior of the inner ring, a negative setting moves into
the exterior of the inner ring).

==== ScaleDenominators

The use of MinScaleDenominators and MaxScaleDenominators within SLD/SE
files can easily be misunderstood because of the meaning of a high or a
low scale. Therefore, this is clarified here according to the standard.
In general the MinScaleDenominator is always a smaller number than the
MaxScaleDenominator. The following example explains, how it works:

[source,xml]
----
<MinScaleDenominator>25000</MinScaleDenominator>
<MaxScaleDenominator>50000</MaxScaleDenominator>
----

This means, that the Symbolizer is being used for scales between 1:25000
and 1:50000.

=== deegree specific extensions

deegree supports some extensions of SLD/SE and filter encoding to enable
more sophisticated styling. The following sections describe the
respective extensions for SLD/SE and filter encoding. For several
specific extensions, there is a deegree SE XML
https://schemas.deegree.org/core/3.5/se/[Schema].

==== SLD/SE extensions

===== Use of alternative Symbols within the WellKnownName

The SLD/SE specification defines a list of standard symbols, which are `circle`,
`triangle`, `star`, `square` and `x`.
In addition to these standard symbols, other predefined and freely configurable
symbols are also available. These are described in the following chapters.

For reference each symbol is shown with the following style.
[source,xml]
----
<Fill>
  <SvgParameter name="fill">#FF0000</SvgParameter>
  <SvgParameter name="fill-opacity">0.4</SvgParameter>
</Fill>
<Stroke>
  <SvgParameter name="stroke">#000000</SvgParameter>
  <SvgParameter name="stroke-width">1</SvgParameter>
</Stroke>
----

====== Predefined symbols

[cols="3"]
.Standard Symbold defined by SLD/SE specification
|===
a| image:se_wkn/circle.png[]   `circle`
a| image:se_wkn/triangle.png[] `triangle`
a| image:se_wkn/star.png[]     `star`
a| image:se_wkn/square.png[]   `square`
a| image:se_wkn/x.png[]        `x`
|
|===

[cols="3"]
.Extended Symbols `shape://`
|===
a| image:se_wkn/shape_backslash.png[] `shape://backslash`
a| image:se_wkn/shape_carrow.png[] `shape://carrow`
a| image:se_wkn/shape_ccarrow.png[] `shape://ccarrow`

a| image:se_wkn/shape_coarrow.png[] `shape://coarrow`
a| image:se_wkn/shape_dot.png[] `shape://dot`
a| image:se_wkn/shape_horline.png[] `shape://horline`

a| image:se_wkn/shape_oarrow.png[] `shape://oarrow`
a| image:se_wkn/shape_plus.png[] `shape://plus`
a| image:se_wkn/shape_slash.png[] `shape://slash`

a| image:se_wkn/shape_times.png[] `shape://times`
a| image:se_wkn/shape_vertline.png[] `shape://vertline`
|
|===

[cols="30,30,40"]
.Extended Symbols `extshape://`
|===
a| image:se_wkn/extshape_arrow.png[] `extshape://arrow`
a| image:se_wkn/extshape_emicircle.png[] `extshape://emicircle`
a| image:se_wkn/extshape_narrow.png[] `extshape://narrow`

a| image:se_wkn/extshape_sarrow.png[] `extshape://sarrow`
a| image:se_wkn/extshape_triangle.png[] `extshape://triangle`
a| image:se_wkn/extshape_triangleemicircle.png[] `extshape://triangleemicircle`
|===

[cols="3"]
.Extended Symbols `qgis://`
|===
a| image:se_wkn/qgis_arrow.png[] `qgis://arrow`
a| image:se_wkn/qgis_arrowhead.png[] `qgis://arrowhead`
a| image:se_wkn/qgis_circle.png[] `qgis://circle`

a| image:se_wkn/qgis_cross.png[] `qgis://cross`
a| image:se_wkn/qgis_cross2.png[] `qgis://cross2`
a| image:se_wkn/qgis_crossfill.png[] `qgis://crossfill`

a| image:se_wkn/qgis_diagonalhalfsquare.png[] `qgis://diagonalhalfsquare`
a| image:se_wkn/qgis_diamond.png[] `qgis://diamond`
a| image:se_wkn/qgis_equilateral_triangle.png[] `qgis://equilateral_triangle`

a| image:se_wkn/qgis_filled_arrowhead.png[] `qgis://filled_arrowhead`
a| image:se_wkn/qgis_halfsquare.png[] `qgis://halfsquare`
a| image:se_wkn/qgis_hexagon.png[] `qgis://hexagon`

a| image:se_wkn/qgis_lefthalftriangle.png[] `qgis://lefthalftriangle`
a| image:se_wkn/qgis_line.png[] `qgis://line`
a| image:se_wkn/qgis_pentagon.png[] `qgis://pentagon`

a| image:se_wkn/qgis_quartercircle.png[] `qgis://quartercircle`
a| image:se_wkn/qgis_quartersquare.png[] `qgis://quartersquare`
a| image:se_wkn/qgis_rectangle.png[] `qgis://rectangle`

a| image:se_wkn/qgis_regular_star.png[] `qgis://regular_star`
a| image:se_wkn/qgis_righthalftriangle.png[] `qgis://righthalftriangle`
a| image:se_wkn/qgis_semicircle.png[] `qgis://semicircle`

a| image:se_wkn/qgis_star.png[] `qgis://star`
a| image:se_wkn/qgis_thirdcircle.png[] `qgis://thirdcircle`
a| image:se_wkn/qgis_triangle.png[] `qgis://triangle`
|===

====== Custom arrow with extshape://arrow

The symbol `extshape://arrow` can be adapted to your own needs with three optional parameters which are:

 * `t`: thickness of the arrow base, in a value range between 0 and 1 with a standard of 0.2
 * `hr`: height over width ratio, in a value range between 0 and 1000 with a standard of 2
 * `ab`: arrow head base ration, in a value range between 0 and 1 with a standard of 0.5

.Example of  `extshape://arrow` which varies `ab` between `0.1` and `1.0`
image::se_wkn_example/extshape_arrow_ab_01_10.png[]
.Example of  `extshape://arrow` which varies `hr` between `0.2` and `2.0`
image::se_wkn_example/extshape_arrow_hr_02_20.png[]
.Example of  `extshape://arrow` which varies `t` between `0.1` and `1.0`
image::se_wkn_example/extshape_arrow_t_00_10.png[]

.Example
[source,xml]
----
<WellKnownName>extshape://arrow?t=0.2&amp;hr=2&amp;ab=0.5</WellKnownName>
----

====== Custom Symbol from SVG path svgpath://

It is also possible to define a symbol from a SVG path data.
The syntax of SVG path data is described at https://www.w3.org/TR/SVG/paths.html#PathData

.Example of custom symbol with \`svgpath://`
[cols="10,90"]
|===
a|image::se_wkn_example/svgpath_example.png[]
a|`svgpath://m 8,14 0,-6 h -4.5 c 0,0 0,-7.5 6.6,-7.5 6,0 6.5,7.5 6.6,7.5 l -4.5,0 0,6 z m -4,0 v -2 h 2 v 2 z`
|===

====== Use Symbol from character code ttf://

Also TrueType font files can be used as source for symbols.
For TrueType fonts installed at System or Java level the syntax is `ttf://Font Name#code`.
If the font is not installed but available it can be sepcified
absolute or relative as `ttf://font.ttf#code`.

The character code has to be specified in hexadecimal notation prefixed with `0x`, `U+` or `\u`.

.Example of `ttf://` symbols
[cols="10,30,10,50"]
|===
a| image::se_wkn_example/ttf_lucida_sans.png[]
a| `ttf://Lucida Sans#0x21BB` +
`ttf://Lucida Sans#U+21BB` +
`ttf://Lucida Sans#\u21bb`
a| image::se_wkn_example/ttf_fontawesome_external.png[]
a| `ttf://../fontawesome-webfont.ttf#0xf13d`
|===

TIP: The character code for fonts installed at System level can be looked up
via the system Character Map application.

====== Custom Symbol from Well Known Text wkt://

It is furthermore possible to specify your own symbols as Well Known Text (WKT).

The following geometry types are currently supported:

* LINESTRING
* LINEARRING
* POLYGON
* MULTIPOINT
* MULTILINESTRING
* MULTICURVE
* MULTIPOLYGON
* GEOMETRYCOLLECTION
* CIRCULARSTRING
* COMPOUNDCURVE
* CURVEPOLYGON

More information about WKT can be found https://en.wikipedia.org/wiki/Well-known_text[here].

.Example of `wkt://` symbols
[cols="10,30,10,50"]
|===
a|image::se_wkn_example/wkt_rhombus.png[]
a|`wkt://POLYGON( (-1 0,0 -1.5,1 0,0 1.5,-1 0) )`
a|image::se_wkn_example/wkt_custom_form.png[]
a|`wkt://COMPOUNDCURVE( (-7.73 -4.59, -7.65 6.02, 0.26 6.07, -1.72 4.89, 0.72 4.54, -1.91 3.51, 0.67 3.05, -1.75 2.14, 0.70 1.68, -1.74 1.28), CIRCULARSTRING (-1.74 1.28, -3.56 2.74, -5.48 1.43) )`
|===

TIP: If unexpected display problems occur with complex symbols (e.g. arcs) a linearized display can be used instead.
To switch to the linearized display please change the prefix from `wkt://` to `wktlin://`.

====== Spacing around the symbol

For each symbol except the symbols `circle`,
`triangle`, `star`, `square` and `x` can be defined with an explicit bound.
This is particularly useful if you want to display an area fill with a symbol.

This explicit limit can be specified either as width and height or as the
lower left and upper right corner.

The syntax is: `wellknownname[width,height]` or `wellknownname[mix,miny,maxx,maxy]`

[cols="10,40,10,40"]
|===
a| image:se_wkn_example/qgis_circle_hatch_default.png[]
a| Regular symbol `qgis://circle`
a| image:se_wkn_example/qgis_circle_hatch_bounded.png[]
a| Symbol with explicit bounds `qgis://circle[-1,-1,3,2]`
|===

TIP: The width and height must be entered in the coordinate system of the symbol.
Most symbols are defined around the zero point with a width of 1.0.
Accordingly it is recommended to start with the values `[1,1]` or `[-0.5,-0.5,0.5,0.5]`.

===== Simplified hatches

To make hatching configuration easier, a new function `HatchingDistance` has been added,
which allows the user to define the size by specifying hatching angle and desired line spacing.

The first parameter is the hatching angle, the second is the line spacing in the unit of the symboliser.

.Example hatches
[cols="10a,15,25,10a,15,25",options="header"]
|===
|   | Rotation | WellKnownName |   | Rotation | WellKnownName
| image:se_wkn_example/hatch_slash.png[]     | 0  | `shape://slash`
| image:se_wkn_example/hatch_backslash.png[] | 0  | `shape://backslash`
| image:se_wkn_example/hatch_times.png[]     | 0  | `shape://times`
| image:se_wkn_example/hatch_10deg.png[]     | 10 | `shape://vertline`
|===
.Symbolizer used in previous example
[source,xml]
----
<!-- PolygonSymbolizer for outline omitted -->
<PolygonSymbolizer uom="http://www.opengeospatial.org/se/units/pixel" xmlns="http://www.opengis.net/se">
 <Fill>
  <GraphicFill>
   <Graphic>
    <Mark>
     <WellKnownName>shape://slash</WellKnownName>
     <Stroke>
      <SvgParameter name="stroke">#000000</SvgParameter>
      <SvgParameter name="stroke-width">1</SvgParameter>
      <SvgParameter name="stroke-linecap">butt</SvgParameter>
     </Stroke>
    </Mark>
    <Size>
      <ogc:Function name="HatchingDistance">
        <ogc:Literal>45</ogc:Literal>
        <ogc:Literal>10</ogc:Literal>
      </ogc:Function>
    </Size>
    <Rotation>0</Rotation>
   </Graphic>
  </GraphicFill>
 </Fill>
</PolygonSymbolizer>
----
TIP: For of the shelf hates, which will create nice results, use the mark symbol `shape://slash`, `shape://backslash`
or `shape://times` for  45°, `shape://horline` for 0° and `shape://vertline` for 90° hatches.
For hatching with user-defined angles it is recommended to use `shape://vertline`.

TIP: With user-defined distances or angles that are not divisible by 45, rounding inaccuracies may occur and become
visible in the results depending on the used styles.

TIP: To get an even hatching we recommend to set the parameter `stroke-linecap` to `butt`.
This is especially recommended for transparent hatches

===== Use of TTF files as Mark symbols

You can use TrueType font files to use custom vector symbols in a
_Mark_ element:

[source,xml]
----
<Mark>
  <OnlineResource xlink:href="filepath/yousans.ttf" />
  <Format>ttf</Format>
  <MarkIndex>99</MarkIndex>
  <Fill>
    <SvgParameter name="fill">#000000</SvgParameter>
    ...
  </Fill>
  <Stroke>
    <SvgParameter name="stroke-opacity">0</SvgParameter>
    ...
  </Stroke>
</Mark>
----

In order to determine the correct index value of the used vector symbol in your TrueType font file, there are several options available: 

* The most convenient way would be by using a JavaScript parser like opentype.js, check https://opentype.js.org/glyph-inspector.html for a usable live-demo.

* Otherwise you can check the index value by using Microsoft Word, as explained in https://support.esri.com/en/technical-article/000004293.

* At last, you could determine the index value by manually reading the cmap table of your TrueType font file. If you are interested in this approach, take a look into a https://sourceforge.net/p/deegree/mailman/deegree-users/thread/20130110115808.GB3576%40theologicum.occamlabs.local/#msg30331881[post] from the deegree mailing list.


===== Label AutoPlacement

deegree has an option for SE LabelPlacement to automatically place
labels on the map. To enable AutoPlacement, you can simply set the
"auto" attribute to "true".

[source,xml]
----
<LabelPlacement>
  <PointPlacement auto="true">
    <Displacement>
      <DisplacementX>0</DisplacementX>
      <DisplacementY>0</DisplacementY>
    </Displacement>
    <Rotation>0</Rotation>
  </PointPlacement>
</LabelPlacement> 
----

TIP: AutoPlacement for labels only works for PointPlacement. AutoPlacement
for LinePlacement is not implemented yet.

===== LinePlacement extensions

There are additional deegree specific LinePlacement parameters available
to enable more sophisticated text rendering along lines:

[width="100%",cols="23%,11%,8%,58%",options="header",]
|===
|Option |Value |Default |Description
|PreventUpsideDown |Boolean |false |Avoids upside down placement of text

|Center |Boolean |false |Places the text in the center of the line

|WordWise |Boolean |true |Tries to place individual words instead of
individual characters
|===

[source,xml]
----
<LinePlacement>
    <IsRepeated>false</IsRepeated>
    <InitialGap>10</InitialGap>
    <PreventUpsideDown>true</PreventUpsideDown>
    <Center>true</Center>
    <WordWise>false</WordWise>
</LinePlacement>
----

===== ExternalGraphic extensions

deegree extends the OnlineResource element of ExternalGraphics to
support ogc:Expressions as child elements. Example:

[source,xml]
----
<ExternalGraphic>
  <OnlineResource>
      <ogc:PropertyName>app:icon</ogc:PropertyName>
  </OnlineResource>
  <Format>image/svg</Format>
</ExternalGraphic> 
----

===== Text with rectangular Halo

For the cartographic design of text, it is possible to place a rectangular box behind the text instead of a halo effect.
To enable the rectangular box behind a text use an negative value for the `Radius` of `Halo` in the `TextSymbolizer`.

.Example of regular `Halo` (`Radius` of `3.0`) on the left and rectangular `Halo` (`Radius` of `-3.0`) on the right.
image::renderstyles_halo_regular_and_boxed.png[]

.Symbolizer used in previous example
[source,xml]
----
<TextSymbolizer>
	<!-- Label omitted -->
	<Font>
		<SvgParameter name="font-family">Sans-Serif</SvgParameter>
		<SvgParameter name="font-size">30</SvgParameter>
	</Font>
	<Halo>
		<Radius>-3.0</Radius>
		<Fill>
			<SvgParameter name="fill">#FF0000</SvgParameter>
			<SvgParameter name="fill-opacity">0.4</SvgParameter>
		</Fill>
	</Halo>
</TextSymbolizer>
----

===== GraphicStroke extensions

By default, a _GraphicStroke_ is drawn repeatedly, but it can also be
only drawn once if the parameter `deegree-graphicstroke-position-percentage`
is defined as a percentage of the line length.
The parameter `deegree-graphicstroke-rotation` controls whether the
_Graphic_ is rotated to follow the angle of the current line segment
or not, values larger than zero enables this. If not specified the
_Graphic_ will follow the angle of the line.

*Rendering of Mark along a geometry*

When deegree renders strokes with _Mark_ it will use the _Fill_ and
_Stroke_ which are defined as sub elements of _Mark_ instead of the
parameter for `color`, `line-width` and `opacity` of _Stroke_.
For _Mark_ whose _Fill_ or _Stroke_ should be omitted, this can be
realized by setting `...-opacity` to zero. Example:

[source,xml]
----
<Stroke>
  <GraphicStroke>
    <Graphic>
      <Mark>
        <WellKnownName>triangle</WellKnownName>
        <Fill>
          <SvgParameter name="fill-opacity">0</SvgParameter>
        </Fill>
        <Stroke>
          <SvgParameter name="stroke-opacity">0</SvgParameter>
        </Stroke>
      </Mark>
      <Size>20</Size>
    </Graphic>
  </GraphicStroke>
  <SvgParameter name="deegree-graphicstroke-position-percentage">50</SvgParameter>
  <SvgParameter name="deegree-graphicstroke-rotation">0</SvgParameter>
</Stroke>
----

NOTE: A typical usage is to draw an arrowhead on a line. This can be
achieved by using a filled `triangle` _Mark_ which is rotated 90 degrees
to the left (`-90`) with an anchor point of `0.75` / `0.5` and
`deegree-graphicstroke-position-percentage` of `0` for the beginning
of a line. To draw it at the end of a line, the _Mark_ has to be rotated
90 degrees to the right (`90`) with an anchor point of `0.25` / `0.5`
and `deegree-graphicstroke-position-percentage` of `100`.

*Rendering of images or SVGs along a geometry*

Both images and SVG can be drawn along a geometry, but it should be
noted that these are best suited for signatures that are drawn only
once or with some gap.
Example of a single SVG at the middle of the line:

[source,xml]
----
<Stroke>
  <GraphicStroke>
    <Graphic>
      <ExternalGraphic>
        <OnlineResource xlink:href="./sample.svg" />
        <Format>svg</Format>
      </ExternalGraphic>
      <Size>20</Size>
    </Graphic>
  </GraphicStroke>
  <SvgParameter name="deegree-graphicstroke-position-percentage">50</SvgParameter>
</Stroke>
----

*Rendering of SVGs as Mark*

To draw only the outline or fill of an SVG with a single color, an SVG
can be used as a `Mark`. Example:

[source,xml]
----
<Stroke>
  <GraphicStroke>
    <Graphic>
      <Mark>
        <OnlineResource xlink:href="./sample.svg" />
        <Format>svg</Format>
        <Fill>
          <SvgParameter name="fill">#FF0000</SvgParameter>
        </Fill>
        <Stroke>
          <SvgParameter name="stroke-opacity">0.0</SvgParameter>
        </Stroke>
      </Mark>
      <Size>20</Size>
    </Graphic>
  </GraphicStroke>
</Stroke>
----

NOTE: Previous versions would have rendered SVG defined  in an
`Graphic`/`ExternalGraphic`/`OnlineResource` like the `Mark` example above.
These have either their configuration converted to
`Graphic`/`Mark`/`OnlineResource` or the option to not render SVGs like
images has to be set for the instance, see <<anchor-appendix>> for details.

==== SE & FE Functions

There are a couple of deegree specific functions which can be expressed
as standard OGC function expressions in SLD/SE. Additionally deegree has
support for all the unctions defined within the SE standard.

===== FormatNumber

This function is needed to format number attributes. It can be used like
in the following example:

[source,xml]
----
<FormatNumber xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="">
  <NumericValue>
    <ogc:PropertyName>app:SHAPE_LEN</ogc:PropertyName>
  </NumericValue>
  <Pattern>############.00</Pattern>
</FormatNumber>
----

===== FormatDate

This function is fully supported, although not fully tested with all
available schema types mentioned in the spec.

[source,xml]
----
<FormatDate xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="">
  <DateValue>
    <ogc:PropertyName>app:TIMESTAMP</ogc:PropertyName>
  </DateValue>
  <Pattern>DD</Pattern>
</FormatDate>
----

===== ChangeCase

This function is used to change the case of property values.

[source,xml]
----
<ChangeCase xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="" direction="toUpper">
  <StringValue>
    <ogc:PropertyName>app:text</ogc:PropertyName>
  </StringValue>
</ChangeCase>
----

===== Concatenate

With the concatenate function it is possible to merge the values of more
than one property to a chain.

[source,xml]
----
<Concatenate xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="">
  <StringValue>
    <ogc:PropertyName>app:text1</ogc:PropertyName>
  </StringValue>
  <StringValue>
    <ogc:PropertyName>app:text2</ogc:PropertyName>
  </StringValue>
  <StringValue>
    <ogc:PropertyName>app:text3</ogc:PropertyName>
  </StringValue>
</Concatenate>
----

===== Trim

The trim function is used to trim string property values.

[source,xml]
----
<Trim xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="" stripOffPosition="both">
  <StringValue>
    <ogc:PropertyName>app:text</ogc:PropertyName>
  </StringValue>
</Trim>
----

===== StringLength

With the StringLength function it is possible to calculate the length of
string property values.

[source,xml]
----
<StringLength xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="">
  <StringValue>
    <ogc:PropertyName>app:text</ogc:PropertyName>
  </StringValue>
</StringLength>
----

===== Substring

With the substring function it is possible to only get a specific
substring of a string property.

[source,xml]
----
<Substring xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="">
  <StringValue>
    <ogc:PropertyName>app:text</ogc:PropertyName>
  </StringValue>
  <Position>1</Position>
  <Length>
    <ogc:Sub>
      <StringPosition fallbackValue="" searchDirection="frontToBack">
        <LookupString>-</LookupString>
        <StringValue>
          <ogc:PropertyName>app:text</ogc:PropertyName>
        </StringValue>
      </StringPosition>
      <ogc:Literal>1</ogc:Literal>
    </ogc:Sub>
  </Length>
</Substring>
----

===== StringPosition

The StringPosition function is made to get the literal at a specific
position from a string property.

[source,xml]
----
<StringPosition xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="" searchDirection="frontToBack">
  <LookupString>-</LookupString>
  <StringValue>
    <ogc:PropertyName xmlns:ogc="http://www.opengis.net/ogc">app:text</ogc:PropertyName>
  </StringValue>
</StringPosition>
----

===== Categorize, Interpolate, Recode

These functions can operate both on alphanumeric properties of features
and on raster data. For color values we extended the syntax a bit to
allow for an alpha channel: #99ff0000 is a red value with an alpha value
of 0x99. This allows the user to create eg. an interpolation from
completely transparent to a completely opaque color value. To work on
raster data you'll have to replace the PropertyName values with
Rasterdata.

For Interpolate only linear interpolation is currently supported.

[source,xml]
----
<Categorize xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc" fallbackValue="#fefdC3">
  <LookupValue>
    <ogc:PropertyName>app:POP2000</ogc:PropertyName>
  </LookupValue>
  <Value>#FFE9D8</Value>
  <Threshold>1000</Threshold>
  <Value>#FBCFAC</Value>
  <Threshold>10000</Threshold>
  <Value>#FAAC6F</Value>
  <Threshold>25000</Threshold>
  <Value>#FD913D</Value>
  <Threshold>100000</Threshold>
  <Value>#FF7000</Value>
</Categorize>
----

[source,xml]
----
<Interpolate xmlns:ogc="http://www.opengis.net/ogc" xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="#005C29" method="color">
  <LookupValue>
    <ogc:PropertyName>app:CODE</ogc:PropertyName>
  </LookupValue>
  <InterpolationPoint>
    <Data>-1</Data>
    <Value>#005C29</Value>
  </InterpolationPoint>
  <InterpolationPoint>
    <Data>100</Data>
    <Value>#067A3A</Value>
  </InterpolationPoint>
  <InterpolationPoint>
    <Data>300</Data>
    <Value>#03A64C</Value>
  </InterpolationPoint>
  <InterpolationPoint>
    <Data>500</Data>
    <Value>#00CF5D</Value>
  </InterpolationPoint>
  <InterpolationPoint>
    <Data>1000</Data>
    <Value>#ffffff</Value>
  </InterpolationPoint>
</Interpolate>
----

[source,xml]
----
<Recode xmlns:app="http://www.deegree.org/app" xmlns="http://www.opengis.net/se" fallbackValue="">
  <LookupValue>
<ogc:PropertyName>app:code</ogc:PropertyName>
  </LookupValue>
  <MapItem>
    <Data>1000</Data>
    <Value>water</Value>
  </MapItem>
  <MapItem>
    <Data>2000</Data>
    <Value>nuclear</Value>
  </MapItem>
  <MapItem>
    <Data>3000</Data>
    <Value>solar</Value>
  </MapItem>
  <MapItem>
    <Data>4000</Data>
    <Value>wind</Value>
  </MapItem>
</Recode>
----

===== General XPath functions

Many useful things can be done by simply using standard XPath 1.0
functions in PropertyName elements.

Access the (local) name of an element (e.g. the name of a referenced
feature / subfeature).

[source,xml]
----
<PropertyName xmlns:app="http://www.deegree.org/app">app:subfeature/*/local-name()</PropertyName>
----
