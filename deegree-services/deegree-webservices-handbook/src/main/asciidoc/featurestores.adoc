[[anchor-configuration-featurestore]]
== Feature stores

Feature stores are workspace resources that provide access to stored
features. The two most common use cases for feature stores are:

* Accessing via <<anchor-configuration-wfs>>
* Providing of data for <<anchor-configuration-feature-layers>>

The remainder of this chapter describes some relevant terms and the
feature store configuration files in detail. You can access this
configuration level by clicking *feature stores* in the service console.
The corresponding resource configuration files are located in
subdirectory _datasources/feature/_ of the active deegree workspace
directory.

.Feature store resources provide access to geo objects
image::workspace-overview-feature.png[Feature store resources provide access to geo objects,scaledwidth=80.0%]

=== Features, feature types and application schemas

Features are abstractions of real-world objects, such as rivers,
buildings, streets or state boundaries. They are the geo objects of a
particular application domain.

A feature types defines the data model for a class of features. For
example, a feature type _River_ could define a class of river features
that all have the same properties.

==== Simple vs. rich features and feature types

Some feature types have a more complex structure than others.
Traditionally, GIS software copes with "simple" feature types:

* Every property is either simple (string, number, date, etc.) or a
geometry
* Only a single property with one name is allowed

Basically, a simple feature type is everything that can be represented
using a single database table or a single shape file. In contrast,
"rich" feature types additionally allow the following:

* Multiple properties with the same name
* Properties that contain other features
* Properties that reference other features or GML objects
* Properties that contain GML core datatypes which are not geometries
(e.g. code types or units of measure)
* Properties that contain generic XML

*Example of a rich feature instance encoded in GML*

[source,xml]
----
<ad:Address gml:id="AD_ADDRESS_b15cd863-1b47-4f3c-9cd5-d5283d674a2b">
  <ad:inspireId>
    <base:Identifier xmlns:base="urn:x-inspire:specification:gmlas:BaseTypes:3.2">
      <base:localId>0532200000000003</base:localId>
      <base:namespace>NL.KAD.BAG</base:namespace>
    </base:Identifier>
  </ad:inspireId>
  <ad:position>
    <ad:GeographicPosition>
      <ad:geometry>
        <gml:Point gml:id="POINT_64fae7bf-a836-44af-a63c-349bed1c6f55" srsName="urn:ogc:def:crs:EPSG::4258">
          <gml:pos>52.689618 5.246345</gml:pos>
        </gml:Point>
      </ad:geometry>
      <ad:specification>entrance</ad:specification>
      <ad:method>byOtherParty</ad:method>
      <ad:default>true</ad:default>
    </ad:GeographicPosition>
  </ad:position>
  <ad:locator>
    <ad:AddressLocator>
      <ad:designator>
        <ad:LocatorDesignator>
          <ad:designator>1</ad:designator>
          <ad:type>2</ad:type>
        </ad:LocatorDesignator>
      </ad:designator>
      <ad:level>unitLevel</ad:level>
    </ad:AddressLocator>
  </ad:locator>
  <ad:validFrom>2009-01-05T23:00:00.000</ad:validFrom>
  <ad:validTo>2299-12-30T23:00:00.000</ad:validTo>
  <ad:beginLifespanVersion xsi:nil="true" nilReason="UNKNOWN" />
  <ad:endLifespanVersion xsi:nil="true" nilReason="UNKNOWN" />
  <ad:component xlink:href="#FEATURE_d4a54e57-91cd-410d-9c3d-b0fafdaa080f" />
  <ad:component xlink:href="#FEATURE_240b3dd2-fc1c-448e-82a4-210cffe6dd34" />
  <ad:component xlink:href="#FEATURE_64f481f4-8a21-4474-8efd-28d01db5e2e3" />
</ad:Address>
----

NOTE: All deegree feature stores support simple feature types, but only the
SQL feature store and the memory feature store support rich feature
types.

==== Application schemas

An application schema defines a number of feature types for a particular
application domain. When referring to an application schema, one usually
means a GML application schema that defines a hierarchy of rich feature
types. Examples for GML application schemas are:

* INSPIRE Data Themes (Annex I, II and III)
* GeoSciML
* CityGML
* XPlanung
* AAA

The following diagram shows a part of the INSPIRE Annex I application
schema in UML form:

.Part of INSPIRE Annex I application schema
image::address_schema.png[Part of INSPIRE Annex I application schema,scaledwidth=50.0%]

NOTE: The SQL feature store or the memory feature store can be used with GML
application schemas.

=== Shape feature store

The shape feature store serves a feature type from an ESRI shape file.
It is currently not transaction capable and only supports simple feature
types.

==== Minimal configuration example

The only mandatory element is _File_. A minimal valid configuration
example looks like this:

*Shape Feature Store config (minimal configuration example)*

[source,xml]
----
<ShapeFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/shape"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/shape
  http://schemas.deegree.org/datasource/feature/shape/3.4.0/shape.xsd">

  <!-- Required: Path to shape file on file system (can be relative) -->
  <File>/tmp/rivers.shp</File>

</ShapeFeatureStore>
----

This configuration will set up a feature store based on the shape file
_/tmp/rivers.shp_ with the following settings:

* The feature store offers the feature type _app:rivers_ (_app_
bound to _http://www.deegree.org/app_)
* SRS information is taken from file _/tmp/rivers.prj_ (if it does not
exist, _EPSG:4326_ is assumed)
* The geometry is added as property _app:GEOMETRY_
* All data columns from file _/tmp/rivers.dbf_ are used as properties
in the feature type
* Encoding of text columns in _/tmp/rivers.dbf_ is guessed based on
actual contents
* An alphanumeric index is created for the dbf to speed up filtering
based on non-geometric constraints

==== More complex configuration example

A more complex example that uses all available configuration options:

*Shape Feature Store config (more complex configuration example)*

[source,xml]
----
<ShapeFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/shape"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/shape
  http://schemas.deegree.org/datasource/feature/shape/3.4.0/shape.xsd">
  <StorageCRS>EPSG:4326</StorageCRS>
  <FeatureTypeName>River</FeatureTypeName>
  <FeatureTypeNamespace>http://www.deegree.org/app</FeatureTypeNamespace>
  <FeatureTypePrefix>app</FeatureTypePrefix>
  <File>/tmp/rivers.shp</File>
  <Encoding>ISO-8859-1</Encoding>
  <GenerateAlphanumericIndexes>false</GenerateAlphanumericIndexes>
  <Mapping>
    <SimpleProperty name="objectid" mapping="OBJECTID" />
    <GeometryProperty name="mygeom" />
  </Mapping>
</ShapeFeatureStore>
----

This configuration will set up a feature store based on the shape file
_/tmp/rivers.shp_ with the following settings:

* SRS of stored geometries is _EPSG:4326_ (no auto-detection)
* The feature store offers the shape file contents as feature type
_app:River_ (_app_ bound to _http://www.deegree.org/app_)
* Encoding of text columns in _/tmp/rivers.dbf_ is _ISO-8859-1_ (no
auto-detection)
* No alphanumeric index is created for the dbf (filtering based on
non-geometric constraints has to be performed in-memory)
* The mapping between the shape file columns and the feature type
properties is customized.
* Property _objectid_ corresponds to column _OBJECTID_ of the shape
file
* Property _geometry_ corresponds to the geometry of the shape file

==== Configuration options

The configuration format for the deegree shape feature store is defined
by schema file
http://schemas.deegree.org/datasource/feature/shape/3.1.0/shape.xsd. The
following table lists all available configuration options. When
specifiying them, their order must be respected.

[width="100%",cols="24%,10%,7%,59%",options="header",]
|===
|Option |Cardinality |Value |Description
|StorageCRS |0..1 |String |CRS of stored geometries

|FeatureTypeName |0..n |String |Local name of the feature type (defaults
to base name of shape file)

|FeatureTypeNamespace |0..1 |String |Namespace of the feature type
(defaults to "http://www.deegree.org/app")

|FeatureTypePrefix |0..1 |String |Prefix of the feature type (defaults
to "app")

|File |1..1 |String |Path to shape file (can be relative)

|Encoding |0..1 |String |Encoding of text fields in dbf file

|GenerateAlphanumericIndexes |0..1 |Boolean |Set to true, if an index
for alphanumeric fields should be generated

|Mapping |0..1 |Complex |Customized mapping between dbf column names and
property names
|===

=== Memory feature store

The memory feature store serves feature types that are defined by a GML
application schema and are stored in memory. It is transaction capable
and supports rich GML application schemas.

==== Minimal configuration example

The only mandatory element is _GMLSchema_. A minimal valid
configuration example looks like this:

*Memory Feature Store config (minimal configuration example)*

[source,xml]
----
<MemoryFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/memory"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/memory
  http://schemas.deegree.org/datasource/feature/memory/3.4.0/memory.xsd">

  <!-- Required: GML application schema file / directory to read feature types from -->
  <GMLSchema version="GML_32">../../appschemas/inspire/annex1/addresses.xsd</GMLSchema>

</MemoryFeatureStore>
----

This configuration will set up a memory feature store with the following
settings:

* The GML 3.2 application schema from file
_../../appschemas/inspire/annex1/addresses.xsd_ is used as application
schema (i.e. scanned for feature type definitions)
* No GML datasets are loaded on startup, so the feature store will be
empty unless an insertion is performed (e.g. via WFS-T)

==== More complex configuration example

A more complex example that uses all available configuration options:

*Memory Feature Store config (more complex configuration example)*

[source,xml]
----
<MemoryFeatureStore configVersion="3.4.0" xmlns="http://www.deegree.org/datasource/feature/memory"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/memory
  http://schemas.deegree.org/datasource/feature/memory/3.4.0/memory.xsd">
  <StorageCRS>urn:ogc:def:crs:EPSG::4258</StorageCRS>
  <GMLSchema version="GML_32">../../appschemas/inspire/annex1/</GMLSchema>
  <GMLFeatureCollection version="GML_32">../../data/gml/address.gml</GMLFeatureCollection>
  <GMLFeatureCollection version="GML_32">../../data/gml/parcels.gml</GMLFeatureCollection>
</MemoryFeatureStore>
----

This configuration will set up a memory feature store with the following
settings:

* Directory _../../appschemas/inspire/annex1/_ is scanned for
_*.xsd_ files. All found files are loaded as a GML 3.2 application
schema (i.e. analyzed for feature type definitions).
* Dataset file _../../data/gml/address.gml_ is loaded on startup. This
must be a GML 3.2 file that contains a feature collection with features
that validates against the application schema.
* Dataset file _../../data/gml/parcels.gml_ is loaded on startup. This
must be a GML 3.2 file that contains a feature collection with features
that validates against the application schema.
* The geometries of loaded features are converted to
_urn:ogc:def:crs:EPSG::4258_.

==== Configuration options

The configuration format for the deegree memory feature store is defined
by schema file
http://schemas.deegree.org/datasource/feature/memory/3.0.0/memory.xsd.
The following table lists all available configuration options (the
complex ones contain nested options themselves). When specifiying them,
their order must be respected.

[width="100%",cols="24%,10%,7%,59%",options="header",]
|===
|Option |Cardinality |Value |Description
|StorageCRS |0..1 |String |CRS of stored geometries

|GMLSchema |1..n |String |Path/URL to GML application schema files/dirs
to read feature types from

|GMLFeatureCollection |0..n |Complex |Path/URL to GML feature
collections documents to read features from
|===

=== Simple SQL feature store

The simple SQL feature store serves simple feature types that are stored
in a spatially-enabled database, such as PostGIS. However, it's not
suited for mapping rich GML application schemas and does not support
transactions. If you need these capabilities, use the SQL feature store
instead.

TIP: If you want to use the simple SQL feature store with Oracle or Microsoft
SQL Server, you will need to add additional modules first. This is
described in <<anchor-db-libraries>>.

==== Minimal configuration example

There are three mandatory elements: _JDBCConnId_, _SQLStatement_ and
_BBoxStatement_. A minimal configuration example looks like this:

*Simple SQL feature store config (minimal configuration example)*

[source,xml]
----
<SimpleSQLFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/simplesql"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/simplesql
  http://schemas.deegree.org/datasource/feature/simplesql/3.4.0/simplesql.xsd">

  <!-- Required: Database connection -->
  <JDBCConnId>connid</JDBCConnId>

  <!-- Required: Query statement -->
  <SQLStatement>
    SELECT name, title, asbinary(the_geom) FROM some_table
    WHERE the_geom &amp;&amp; st_geomfromtext(?, -1)
  </SQLStatement>

  <!-- Required: Bounding box statement -->
  <BBoxStatement>SELECT astext(ST_Estimated_Extent('some_table', 'the_geom')) as bbox</BBoxStatement>

</SimpleSQLFeatureStore>
----

==== More complex configuration example

*Simple SQL feature store config (more complex configuration example)*

[source,xml]
----
<SimpleSQLFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/simplesql"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/simplesql
  http://schemas.deegree.org/datasource/feature/simplesql/3.4.0/simplesql.xsd">

  <!-- Required: Database connection -->
  <JDBCConnId>connid</JDBCConnId>

  <!-- Required: Query statement -->
  <SQLStatement>
    SELECT name, title, asbinary(the_geom) FROM some_table
    WHERE the_geom &amp;&amp; st_geomfromtext(?, -1)
  </SQLStatement>

  <!-- Required: Bounding box statement -->
  <BBoxStatement>SELECT astext(ST_Estimated_Extent('some_table', 'the_geom')) as bbox</BBoxStatement>

</SimpleSQLFeatureStore>
----

==== Configuration options

The configuration format is defined by schema file
http://schemas.deegree.org/datasource/feature/simplesql/3.0.1/simplesql.xsd.
The following table lists all available configuration options (the
complex ones contain nested options themselves). When specifiying them,
their order must be respected.

[width="100%",cols="24%,10%,7%,59%",options="header",]
|===
|Option |Cardinality |Value |Description
|StorageCRS |0..1 |String |CRS of stored geometries

|FeatureTypeName |0..n |String |Local name of the feature type (defaults
to table name)

|FeatureTypeNamespace |0..1 |String |Namespace of the feature type
(defaults to "http://www.deegree.org/app")

|FeatureTypePrefix |0..1 |String |Prefix of the feature type (defaults
to "app")

|JDBCConnId |1..1 |String |Identifier of the database connection

|SQLStatement |1..1 |String |SELECT statement that defines the feature
type

|BBoxStatement |1..1 |String |SELECT statement for the bounding box of
the feature type

|LODStatement |0..n |Complex |Statements for specific WMS scale ranges
|===

[[anchor-configuration-sqlfeaturestore]]
=== SQL feature store

The SQL feature store allows to configure highly flexible mappings
between feature types and database tables. It can be used for simple
mapping tasks (mapping a single database table to a feature type) as
well as sophisticated ones (mapping a complete INSPIRE Data Theme to
dozens or hundreds of database tables). As an alternative to relational
mapping, it additionally offers so-called BLOB mapping which stores any
kind of rich feature using a fixed and very simple database schema. In
contrast to the simple SQL feature store, the SQL feature store is
transaction capable (even for complex mappings) and ideally suited for
mapping rich GML application schemas.

==== Minimal configuration example

A very minimal valid configuration example looks like this:

*SQL feature store: Minimal configuration*

[source,xml]
----
<SQLFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/sql"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/sql
  http://schemas.deegree.org/datasource/feature/sql/3.4.0/sql.xsd">
  <JDBCConnId>postgis</JDBCConnId>
  <FeatureTypeMapping table="country"/>
</SQLFeatureStore>
----

This configuration defines a SQL feature store resource with the
following properties:

* JDBC connection resource with identifier _postgis_ is used to
connect to the database
* A single table (_country_) is mapped
* Feature type is named _app:country_ (app=http://www.deegree.org/app)
* Properties of the feature type are automatically derived from table
columns
* Every primitive column (number, string, date) is used as a primitive
property
* Every geometry column is used as a geometry property (storage CRS is
determined automatically, inserted geometries are transformed by
deegree, if necessary)
* Feature id (_gml:id_) is based on primary key column, prefixed by
_COUNTRY__
* For insert transactions, it is expected that the database generates
new primary keys value automatically (primary key column must have a
trigger or a suitable type such as SERIAL in PostgreSQL)

==== More complex configuration example

A more complex example:

*SQL feature store: More complex configuration*

[source,xml]
----
<SQLFeatureStore xmlns="http://www.deegree.org/datasource/feature/sql" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:base="urn:x-inspire:specification:gmlas:BaseTypes:3.2" xmlns:ad="urn:x-inspire:specification:gmlas:Addresses:3.0"
  xmlns:gml="http://www.opengis.net/gml/3.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" configVersion="3.4.0"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/sql http://schemas.deegree.org/datasource/feature/sql/3.4.0/sql.xsd">
  <JDBCConnId>inspire</JDBCConnId>
  <StorageCRS srid="-1" dim="2D">EPSG:4258</StorageCRS>
  <GMLSchema>../../appschemas/inspire/annex1/Addresses.xsd</GMLSchema>
  <GMLSchema>../../appschemas/inspire/annex1/AdministrativeUnits.xsd</GMLSchema>
  <GMLSchema>../../appschemas/inspire/annex1/CadastralParcels.xsd</GMLSchema>

  <FeatureTypeMapping name="ad:Address" table="ad_address">
    <FIDMapping prefix="AD_ADDRESS_">
      <Column name="attr_gml_id" type="string" />
      <UUIDGenerator />
    </FIDMapping>
    <Complex path="ad:inspireId">
      <Complex path="base:Identifier">
        <Primitive path="base:localId" mapping="localid" />
        <Primitive path="base:namespace" mapping="'NL.KAD.BAG'" />
      </Complex>
    </Complex>
    <Complex path="ad:position">
      <Join table="ad_address_ad_position" fromColumns="fid" toColumns="fk" />
      <Complex path="ad:GeographicPosition">
        <Complex path="ad:geometry">
          <Geometry path="." mapping="value" />
        </Complex>
        <Complex path="ad:specification">
          <Primitive path="text()" mapping="'entrance'" />
        </Complex>
        <Complex path="ad:method">
          <Primitive path="text()" mapping="'byOtherParty'" />
        </Complex>
        <Primitive path="ad:default" mapping="'true'" />
      </Complex>
    </Complex>
    <Complex path="ad:locator">
      <Join table="ad_address_ad_locator" fromColumns="attr_gml_id" toColumns="parentfk" orderColumns="num"
        numbered="true" />
      <Complex path="ad:AddressLocator">
        <Complex path="ad:designator">
          <Join table="ad_address_ad_locator_ad_addresslocator_ad_designator" fromColumns="id" toColumns="parentfk"
            orderColumns="num" numbered="true" />
          <Complex path="ad:LocatorDesignator">
            <Primitive path="ad:designator" mapping="ad_addresslocator_ad_locatordesignator_ad_designator" />
            <Complex path="ad:type">
              <Primitive path="text()" mapping="ad_addresslocator_ad_locatordesignator_ad_type" />
              <Primitive path="@codeSpace" mapping="ad_addresslocator_ad_locatordesignator_ad_type_attr_codespace" />
            </Complex>
          </Complex>
        </Complex>
        <Complex path="ad:level">
          <Primitive path="text()" mapping="ad_addresslocator_ad_level" />
          <Primitive path="@codeSpace" mapping="ad_addresslocator_ad_level_attr_codespace" />
        </Complex>
      </Complex>
    </Complex>
    <Complex path="ad:validFrom">
      <Primitive path="text()" mapping="ad_validfrom" />
      <Primitive path="@nilReason" mapping="ad_validfrom_attr_nilreason" />
      <Primitive path="@xsi:nil" mapping="ad_validfrom_attr_xsi_nil" />
    </Complex>
    <Complex path="ad:validTo">
      <Primitive path="text()" mapping="ad_validto" />
      <Primitive path="@nilReason" mapping="ad_validto_attr_nilreason" />
      <Primitive path="@xsi:nil" mapping="ad_validto_attr_xsi_nil" />
    </Complex>
    <Complex path="ad:beginLifespanVersion">
      <Primitive path="text()" mapping="ad_beginlifespanversion" />
      <Primitive path="@nilReason" mapping="ad_beginlifespanversion_attr_nilreason" />
      <Primitive path="@xsi:nil" mapping="ad_beginlifespanversion_attr_xsi_nil" />
    </Complex>
    <Complex path="ad:endLifespanVersion">
      <Primitive path="text()" mapping="ad_endlifespanversion" />
      <Primitive path="@nilReason" mapping="ad_endlifespanversion_attr_nilreason" />
      <Primitive path="@xsi:nil" mapping="ad_endlifespanversion_attr_xsi_nil" />
    </Complex>
    <Complex path="ad:component">
      <Join table="ad_address_ad_component" fromColumns="attr_gml_id" toColumns="parentfk" orderColumns="num"
        numbered="true" />
      <Feature path=".">
        <Href mapping="href" />
      </Feature>
    </Complex>
  </FeatureTypeMapping>

</SQLFeatureStore>
----

This configuration snippet defines a SQL feature store resource with the
following properties:

* JDBC connection resource with identifier _inspire_ is used to
connect to the database
* Storage CRS is _EPSG:4258_, database srid is _-1_ (inserted
geometries are transformed by deegree to the storage CRS, if necessary)
* Feature types are read from three GML schema files
* A single feature type _ad:Address_
(ad=urn:x-inspire:specification:gmlas:Addresses:3.0) is mapped
* The root table of the mapping is _ad_address_
* Feature type is mapped to several tables
* Feature id (_gml:id_) is based on column _attr_gml_id_, prefixed
by _AD_ADDRESS___
* For insert transactions, new values for column _attr_gml_id_ in the
root table are created using the UUID generator. For the joined tables,
the database has to create new primary keys value automatically (primary
key columns must have a trigger or a suitable type such as SERIAL in
PostgreSQL)

==== Overview of configuration options

The SQL feature store configuration format is defined by schema file
http://schemas.deegree.org/datasource/feature/sql/3.4.0/sql.xsd. The
following table lists all available configuration options (the complex
ones contain nested options themselves). When specifying them, their
order must be respected:

[width="100%",cols="26%,10%,7%,57%",options="header",]
|===
|Option |Cardinality |Value |Description
|_<JDBCConnId>_ |1 |String |Identifier of the database connection

|_<DisablePostFiltering>_ |0..1 |Empty |If present, queries that
require in-memory filtering are rejected

|_<StorageCRS>_ |0..1 |Complex |CRS of stored geometries

|_<GMLSchema>_ |0..n |String |Path/URL to GML application schema
files/dirs to read feature types from

|_<NullEscalation>_ |0..1 |Boolean |Controls the handling of NULL
values on reconstruction from the DB

|_<BLOBMapping>_ |0..1 |Complex |Activates a special mapping mode that
uses BLOBs for storing features

|_<FeatureTypeMapping>_ |0..n |Complex |Mapping between a feature type
and a database table
|===

The usage of these options and their sub-options is explained in the
remaining sections.

[[anchor-configuration-tabledriven]]
==== Mapping tables to simple feature types

This section describes how to define the mapping of database tables to
simple feature types. Each _<FeatureTypeMapping>_ defines the mapping
between one table and one feature type:

*SQL feature store: Mapping a single table*

[source,xml]
----
<SQLFeatureStore configVersion="3.4.0"
xmlns="http://www.deegree.org/datasource/feature/sql"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.deegree.org/datasource/feature/sql
  http://schemas.deegree.org/datasource/feature/sql/3.4.0/sql.xsd">
<JDBCConnId>postgis</JDBCConnId>
<FeatureTypeMapping table="country"/>
</SQLFeatureStore>
----

This example assumes that the database contains a table named
_country_ within the default database schema (for PostgreSQL
_public_). Alternatively, you can qualify the table name with the
database schema, such as _public.country_. The feature store will try
to automatically determine the columns of the table and derive a
suitable feature type:

* Feature type name: _app:country_ (app=http://www.deegree.org/app)
* Feature id (_gml:id_) based on primary key column of table
_country_
* Every primitive column (number, string, date) is used as a primitive
property
* Every geometry column is used as a geometry property

A single configuration file may map more than one table. The following
example defines two feature types, based on tables _country_ and
_cities_.

*SQL feature store: Mapping two tables*

[source,xml]
----
<SQLFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/sql"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/sql
  http://schemas.deegree.org/datasource/feature/sql/3.4.0/sql.xsd">
  <JDBCConnId>postgis</JDBCConnId>
  <FeatureTypeMapping table="country"/>
  <FeatureTypeMapping table="city"/>
</SQLFeatureStore>
----

There are several options for _<FeatureTypeMapping>_ that give you
more control over the derived feature type definition. The following
table lists all available options (the complex ones contain nested
options themselves):

[width="100%",cols="17%,11%,8%,64%",options="header",]
|===
|Option |Cardinality |Value |Description
|_table_ |1 |String |Name of the table to be mapped (can be qualified
with database schema)

|_name_ |0..1 |QName |Name of the feature type

|_<FIDMapping>_ |0..1 |Complex |Defines the mapping of the feature id

|_<Primitive>_ |0..n |Complex |Defines the mapping of a
primitive-valued column

|_<Geometry>_ |0..n |Complex |Defines the mapping of a geometry-valued
column
|===

NOTE: The order of child elements _<Primitive>_ and _<Geometry>_ is not
restricted. They may appear in any order.

These options and their sub-options are explained in the following
subsections.

===== Customizing the feature type name

By default, the name of a mapped feature type will be derived from the
table name. If the table is named _country_, the feature type name
will be _app:country_ (app=http://www.deegree.org/app). The _name_
attribute allows to set the feature type name explicity. In the
following example, it will be _app:Land_ (Land is German for country).

*SQL feature store: Customizing the feature type name*

[source,xml]
----
...
  <FeatureTypeMapping table="country" name="Land"/>
...
----

The name of a feature type is always a qualified XML name. You can use
standard XML namespace binding mechanisms to control the namespace and
prefix of the feature type name:

*SQL feature store: Customizing the feature type namespace and prefix*

[source,xml]
----
...
  <FeatureTypeMapping xmlns:myns="http://mydomain.org/myns" table="country" name="myns:Land"/>
...
----

===== Customizing the feature id

By default, values for the feature id (_gml:id_ attribute in GML) will
be based on the primary key column of the mapped table. Values from this
column will be prepended with a prefix that is derived from the feature
type name. For example, if the feature type name is _app:Country_, the
prefix is _APP_COUNTRY_. The feature instance that is built from the
table row with primary key _42_ will have feature id
_APP_COUNTRY42_.

If this is not what you want, or automatic detection of the primary key
column fails, customize the feature id mapping using the
_<FIDMapping>_ option:

*SQL feature store: Customizing the feature id mapping*

[source,xml]
----
...
<FeatureTypeMapping table="country">
  <FIDMapping prefix="C_">
    <Column name="fid" />
  </FIDMapping>
</FeatureTypeMapping>
...
----

Here are the options for _<FIDMapping>_:

[width="100%",cols="17%,11%,8%,64%",options="header",]
|===
|Option |Cardinality |Value |Description
|_prefix_ |0..1 |String |Feature id prefix, default: derived from
feature type name

|_<Column>_ |1..n |Complex |Column that stores (a part of) the feature
id
|===

As _<Column>_ may occur more than once, you can define that the
feature id is constructed from multiple columns:

*SQL feature store: Customizing the feature id mapping*

[source,xml]
----
...
<FeatureTypeMapping table="country">
  <FIDMapping prefix="C_">
    <Column name="key1" />
    <Column name="key2" />
  </FIDMapping>
</FeatureTypeMapping>
...
----

Here are the options for _<Column>_:

[width="100%",cols="17%,11%,8%,64%",options="header",]
|===
|Option |Cardinality |Value |Description
|_name_ |1 |String |Name of the database column

|_type_ |0..1 |String |Column type (string, boolean, decimal, double
or integer), default: auto
|===

NOTE: Technically, the feature id prefix is important to determine the feature
type when performing queries by feature id. Every
_<FeatureTypeMapping>_ must have a unique feature id prefix.

===== Customizing the mapping between columns and properties

By default, the SQL feature store will try to automatically determine
the columns of the table and derive a suitable feature type:

* Every primitive column (number, string, date) is used as a primitive
property
* Every geometry column is used as a geometry property

If this is not what you want, or automatic detection of the column types
fails, use _<Primitive>_ and _<Geometry>_ to control the property
definitions of the feature type and the column-to-property mapping:

*SQL feature store: Customizing property definitions and the
column-to-property mapping*

[source,xml]
----
...
  <FeatureTypeMapping table="country">
    <Primitive path="property1" mapping="prop1" type="string"/>
    <Geometry path="property2" mapping="the_geom" type="Point">
      <StorageCRS srid="-1">EPSG:4326</StorageCRS>
    </Geometry>
    <Primitive path="property3" mapping="prop2" type="integer"/>
  </FeatureTypeMapping>
...
----

This example defines a feature type with three properties:

* _property1_, type: primitive (string), mapped to column _prop1_
* _property2_, type: geometry (point), mapped to column _the_geom_,
storage CRS is _EPSG:4326_, database srid is _-1_
* _property3_, type: primitive (integer), mapped to column _prop2_

The following table lists all available configuration options for
_<Primitive>_ and _<Geometry>_:

[width="100%",cols="20%,11%,7%,62%",options="header",]
|===
|Option |Cardinality |Value |Description
|_path_ |1 |QName |Name of the property

|_mapping_ |1 |String |Name of the database column

|_type_ |1 |String |Property/column type

|_<Join>_ |0..1 |Complex |Defines a change in the table context

|_<CustomConverter>_ |0..1 |Complex |Plugs-in a specialized
DB-to-ObjectModel converter implementation

|_<StorageCRS>_ |0..1 |Complex |CRS of stored geometries and database
srid (only for _<Geometry>_)
|===

NOTE: If your configuration file is stored in UTF-8 encoding deegree allows
special chars from this charset in the mapping (e.g. the property Straße
can be stored in the column 'strasse' or 'straße'). Required is that the
database supports UTF-8 as well.

==== Mapping GML application schemas

The former section assumed a mapping configuration that didn't use a
given GML application schema. If a GML application schema is available
and specified using _<GMLSchema>_, the mapping possibilities and
available options are extended. We refer to these two modes as
*table-driven mode* (without GML schema) and *schema-driven mode* (with
GML schema).

Here's a comparison of table-driven and schema-driven mode:

[width="100%",cols="33%,32%,35%",options="header",]
|===
| |Table-driven mode |Schema-driven mode
|GML application schema |Derived from tables |Must be provided

|Data model (feature types) |Derived from tables |Derived from GML app
schema

|GML version |Any (GML 2, 3.0, 3.1, 3.2) |Fixed to version of app schema

|Mapping principle |Property to table column |XPath-based or BLOB-based

|Supported mapping complexity |Low |Very high
|===

NOTE: If you want to create a relational mapping for an existing GML
application schema (e.g. INSPIRE Data Themes, GeoSciML, CityGML,
XPlanung, AAA), always copy the schema files into the _appschemas/_
directory of your workspace and reference the schema in your
configuration.

In schema-driven mode, the SQL feature store extracts detailed feature
type definitions and property declarations from GML application schema
files. A basic configuration for schema-driven mode defines the JDBC
connection id, the general CRS of the stored geometries and one or more
GML application schema files:

*SQL FeatureStore (schema-driven mode): Skeleton config*

[source,xml]
----
<SQLFeatureStore configVersion="3.4.0"
  xmlns="http://www.deegree.org/datasource/feature/sql"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.deegree.org/datasource/feature/sql
  http://schemas.deegree.org/datasource/feature/sql/3.4.0/sql.xsd">

  <JDBCConnId>postgis</JDBCConnId>
  <StorageCRS dim="2D" srid="-1">EPSG:4258</StorageCRS>
  <GMLSchema>../../appschemas/inspire/annex1/ad_address.xsd</GMLSchema>

</SQLFeatureStore>
----

===== Recommended workflow

NOTE: This section assumes that you already have an existing database that you
want to map to a GML application schema. If you want to derive a
database model from a GML application schema, see
<<anchor-mapping-wizard>>.

Manually creating a mapping for a rich GML application schema may appear
to be a dauting task at first sight. Especially when you are still
trying to figure out how the configuration concepts work, you will be
using a lot of trial-and-error. Here are some general practices to make
this as painless as possible.

* Map one property of a feature type at a time.
* Use the *Reload* link in the services console to activate changes.
* After changing the configuration file, make sure that the status of
the feature store stays green (in the console). If an exclamation mark
occurs, you have an error in your configuration. Check the error message
and fix it.
* Check the results of your change (see below)
* Once you're satisfied, move on to the next property (or feature type)

Set up a WFS configuration, so you can use WFS GetFeature-requests to
check whether your feature mapping works as expected. You can use your
web browser for that. After each configuration change, perform a
GetFeature-request to see the effect. Suitable WFS requests depend on
the WFS version, the GML version and the name of the feature type. Here
are some examples:

* WFS 1.0.0 (GML 2):
http://localhost:8080/services?service=WFS&version=1.0.0&request=GetFeature&typeName=ad:Address&maxFeatures=1
* WFS 1.1.0 (GML 3.1):
http://localhost:8080/services?service=WFS&version=1.1.0&request=GetFeature&typeName=ad:Address&maxFeatures=1
* WFS 2.0.0 (GML 3.2):
http://localhost:8080/services?service=WFS&version=2.0.0&request=GetFeature&typeName=ad:Address&count=1

In order to successfully create a mapping for a feature type from a GML
application schema, you have to know the structure and the data types of
the feature type. For example, if you want to map feature type
_ad:Address_ from INSPIRE Annex I, you have to know that it has a
required property called _ad:inspireId_ that has a child element with
name _base:Identifier_. Here's a list of possible options to learn the
data model of an application schema:

* Manually (or with the help of a generic XML tool such as XMLSpy)
analyze the GML application schema to determine the feature types and
understand their data model
* Use the services console to auto-generate a mapping configuration (see
<<anchor-mapping-wizard>>). It should reflect the structure and
datatypes correctly. Auto-generate the mapping, create a copy of the
file and start with a minimal version (_FeatureTypeMapping_ by
_FeatureTypeMapping_, property by property). Adapt it to your own
database tables and columns and remove optional elements and attributes
that you don't want to map.
* Use the deegree support options (mailing lists, commercial support) to
get help.

NOTE: The deegree project aims for a user-interface to help with all steps of
creating mapping configurations. If you are interested in working on
this (or funding it), don't hesitate to contact the project bodies.

[[anchor-mapping-rich-feature-types]]
===== Mapping rich feature types

In schema-driven mode, the _<FeatureTypeMapping>_ element basically
works as in table-driven mode (see
<<anchor-configuration-tabledriven>>). It defines a mapping between a
table in the database and a feature type. However, there are additional
possibilities and it's usually more suitable to focus on feature types
and XML nodes instead of tables and table columns. Here's an overview of
the _<FeatureTypeMapping>_ options and their meaning in schema-driven
mode:

[width="100%",cols="17%,11%,8%,64%",options="header",]
|===
|Option |Cardinality |Value |Description
|_table_ |1 |String |Name of the table to be mapped (can be qualified
with database schema)

|_name_ |0..1 |QName |Name of the feature type

|_<FIDMapping>_ |1 |Complex |Defines the mapping of the feature id

|_<Primitive>_ |0..n |Complex |Defines the mapping of a
primitive-valued node

|_<Geometry>_ |0..n |Complex |Defines the mapping of a geometry-valued
node

|_<Complex>_ |0..n |Complex |Defines the mapping of a complex-valued
node

|_<Feature>_ |0..n |Complex |Defines the mapping of a feature-valued
node
|===

NOTE: The order of child elements _<Primitive>_, _<Geometry>_,
_<Complex>_ and _<Feature>_ is not restricted. They may appear in
any order.

We're going to explore the additional options by describing the
necessary steps for mapping feature type _ad:Address_ (from INSPIRE
Annex I) to an example database. Start with a single
_<FeatureTypeMapping>_. Provide the table name and the mapping for the
feature identifier. The example uses a table named _ad_address_ and a
key column named _fid_:

*SQL feature store (schema-driven mode): Start configuration*

[source,xml]
----
...
<FeatureTypeMapping name="ad:Address" table="ad_address" xmlns:ad="urn:x-inspire:specification:gmlas:Addresses:3.0">
  <FIDMapping>
    <Column name="fid" />
  </FIDMapping>
</FeatureTypeMapping>
...
----

TIP: In schema-driven mode, there is no automatic detection of columns,
column types or primary keys. You always have to specify
_<FIDMapping>_.

TIP: If this configuration matches your database and you have a working WFS
resource, you should be able to query the feature type (although no
properties will be returned):
http://localhost:8080/services?service=WFS&version=2.0.0&request=GetFeature&typeName=ad:Address&count=1

Mapping rich feature types works by associating XML nodes of a feature
instance with rows and columns in the database. The table context (the
current row) is changed when necessary. In the beginning of a
_<FeatureTypeMapping>_, the current context node is an _ad:Address_
element and the current table context is a row of table _ad_address_.
The first (required) property that we're going to map is
_ad:inspireId_. The schema defines that _ad:inspireId_ has as child
element named _base:Identifier_ which in turn has two child elements
named _base:localId_ and _base:namespace_. Lets's assume that we
have a column _localid_ in our table, that we want to map to
_base:localId_, but for _base:namespace_, we don't have a
corresponding column. We want this element to have the fixed value
_NL.KAD.BAG_ for all instances of _ad:Address_. Here's how to do it:

*SQL feature store (schema-driven mode): Complex elements and constant
mappings*

[source,xml]
----
<FeatureTypeMapping name="ad:Address" table="ad_address" xmlns:base="urn:x-inspire:specification:gmlas:BaseTypes:3.2" xmlns:ad="urn:x-inspire:specification:gmlas:Addresses:3.0">
  <FIDMapping>
    <Column name="fid" />
  </FIDMapping>

  <Complex path="ad:inspireId">
    <Complex path="base:Identifier">
      <Primitive path="base:localId" mapping="localid"/>
      <Primitive path="base:namespace" mapping="'NL.KAD.BAG'"/>
    </Complex>
  </Complex>

</FeatureTypeMapping>
----

There are several things to observe here. The _Complex_ element occurs
twice. In the _path_ attribute of the first occurrence, we specified
the qualified name of the (complex) property we want to map
(_ad:inspireId_). The nested _Complex_ targets child element
_base:Identifier_ of _ad:inspireId_. And finally, the _Primitive_
elements specify that child element _base:localId_ is mapped to column
_localid_ and element _base:namespace_ is mapped to constant
_NL.KAD.BAG_ (note the single quotes around _NL.KAD.BAG_).

To summarize:

* _Complex_ is used to select a (complex) child element to be mapped.
It is a container for child mapping elements (_Primitive_,
_Geometry_, _Complex_ or _Feature_)
* In the _mapping_ attribute of _Primitive_, you can also use
constants, not only column names

The next property we want to map is _ad:position_. It contains the
geometry of the address, but the actual GML geometry is nested on a
deeper level and the property can occur multiple times. In our database,
we have a table named _ad_address_ad_position_ with columns _fk_
(foreign key to ad_address) and _value_ (geometry). Here's the
extended mapping:

*SQL feature store (schema-driven mode): Join elements and XPath
expressions*

[source,xml]
----
<FeatureTypeMapping name="ad:Address" table="ad_address" xmlns:base="urn:x-inspire:specification:gmlas:BaseTypes:3.2" xmlns:ad="urn:x-inspire:specification:gmlas:Addresses:3.0">
  <FIDMapping>
    <Column name="fid" />
  </FIDMapping>

  <Complex path="ad:inspireId">https://xxx[]
    <Complex path="base:Identifier">
      <Primitive path="base:localId" mapping="localid" />
      <Primitive path="base:namespace" mapping="'NL.KAD.BAG'" />
    </Complex>
  </Complex>

  <Complex path="ad:position">
    <Join table="ad_address_ad_position" fromColumns="fid" toColumns="fk" />
    <Complex path="ad:GeographicPosition">
      <Complex path="ad:geometry">
        <Geometry path="." mapping="value" />
      </Complex>
      <Complex path="ad:specification">
        <Primitive path="text()" mapping="'entrance'" />
      </Complex>
      <Complex path="ad:method">
        <Primitive path="text()" mapping="'byOtherParty'" />
      </Complex>
      <Primitive path="ad:default" mapping="'true'" />
    </Complex>
  </Complex>

</FeatureTypeMapping>
----

Again, the _Complex_ element is used to drill into the XML structure
of the property and several elements are mapped to constant values. But
there are also new things to observe:

* The first child element of a _<Complex>_ (or _<Primitive>_,
_<Geometry>_ or _<Feature>_) can be _<Join>_. _<Join>_ performs
a table change: table rows corresponding to _ad:position_ are not
stored in the root feature type table (_ad_address_), but in a joined
table. All siblings of _<Join>_ (or their children) refer to this
joined table (_ad_address_ad_position_). The join condition that
determines the related rows in the joined table is
_ad_address.fid=ad_address_ad_position.fk_. _<Join>_ is described in
detail in the next section.
* Valid expressions for _path_ can also be _._ (current node) and
_text()_ (primitive value of the current node).

Let's move on to the mapping of property _ad:component_. This property
can occur multiple times and contains (a reference to) another feature.

*SQL feature store (schema-driven mode): Feature elements*

[source,xml]
----
<FeatureTypeMapping name="ad:Address" table="ad_address" xmlns:base="urn:x-inspire:specification:gmlas:BaseTypes:3.2" xmlns:ad="urn:x-inspire:specification:gmlas:Addresses:3.0">
    [...]
    <Complex path="ad:component">
      <Join table="ad_address_ad_component" fromColumns="fid" toColumns="fk"/>
      <Feature path=".">
        <Href mapping="href"/>
      </Feature>
    </Complex>
</FeatureTypeMapping>
----

As in the mapping of _ad:position_, a _<Join>_ is used to change the
table context. The table that stores the information for
_ad:component_ properties is _ad_address_ad_component_. The
_<Feature>_ declares that we want to map a feature-valued node and
it's _<Href>_ sub-element defines that column _href_ stores the
value of the _xlink:href_ attribute.

Here is an overview of all options for _<Complex>_ elements:

[width="100%",cols="20%,11%,7%,62%",options="header",]
|===
|Option |Cardinality |Value |Description
|_path_ |1 |QName |Name/XPath-expression that determines the element
to be mapped

|_<Join>_ |0..1 |Complex |Defines a change in the table context

|_<CustomConverter>_ |0..1 |Complex |Plugs-in a specialized
DB-to-ObjectModel converter implementation

|_<Primitive>_ |0..n |Complex |Defines the mapping of a
primitive-valued node

|_<Geometry>_ |0..n |Complex |Defines the mapping of a geometry-valued
node

|_<Complex>_ |0..n |Complex |Defines the mapping of a complex-valued
node

|_<Feature>_ |0..n |Complex |Defines the mapping of a feature-valued
node
|===

NOTE: The order of child elements _<Primitive>_, _<Geometry>_,
_<Complex>_ and _<Feature>_ is not restricted. They may appear in
any order.

Here is an overview on all options for _<Feature>_ elements:

[width="100%",cols="20%,11%,7%,62%",options="header",]
|===
|Option |Cardinality |Value |Description
|_path_ |1 |QName |Name/XPath-expression that determines the element
to be mapped

|_<CustomConverter>_ |0..1 |Complex |Plugs-in a specialized
DB-to-ObjectModel converter implementation

|_<Href>_ |0..1 |Complex |Defines the column that stores the value for
_xlink:href_
|===

[[anchor-mapping-strategies-href-attributes]]
===== Mapping strategies for xlink:href attributes

There are two different use cases when xlink:href attributes are used:

* {blank}
[arabic]
. Reference on other feature.
* {blank}
[arabic, start=2]
. xlink:href value is used as static value. For example, if a user wants
to filter on INSPIRE codelists, filtering is executed on the value of
xlink:href.

Case 1. does not allow filtering on the value of xlink:href itself. Case
2. allows filtering on the static value of the xlink:href attribute but
the linked feature is not resolved anymore.

Those two cases can be realized by different mappings in SQL feature
store configuration:

* {blank}
[arabic]
. Feature mapping is used:

[source,xml]
----
<Feature path=".">
  <Join table="?" fromColumns="designationtype_designation_fk" toColumns="id"/>
  <Href mapping="designationtype_designation_href"/>
</Feature>
----

* {blank}
[arabic, start=2]
. Primitive mapping is used:

[source,xml]
----
<Primitive path="@xlink:href" mapping="designationtype_designation_href"/>
----

For more details see chapter <<anchor-mapping-rich-feature-types>>.

===== Changing the table context

At the beginning of a _<FeatureTypeMapping>_, the current table
context is the one specified by the _table_ attribute. In the
following example snippet, this would be table _ad_address_.

*SQL feature store: Initial table context*

[source,xml]
----
<FeatureTypeMapping name="ad:Address" table="ad_address">
 [...]
  <Complex path="gml:identifier">
    <Primitive path="text()" mapping="gml_identifier"/>
    <Primitive path="@codeSpace" mapping="gml_identifier_attr_codespace"/>
  </Complex>
 [...]
</FeatureTypeMapping>
----

Note that all mapped columns stem from table _ad_address_. This is
fine, as each feature can only have a single _gml:identifier_
property. However, when mapping a property that may occur any number of
times, we will have to access the values for this property in a separate
table.

*SQL feature store: Changing the table context*

[source,xml]
----
<FeatureTypeMapping name="ad:Address" table="ad_address">
 [...]
  <Complex path="gml:identifier">
    <Primitive path="text()" mapping="gml_identifier"/>
    <Primitive path="@codeSpace" mapping="gml_identifier_attr_codespace"/>
  </Complex>
 [...]
  <Complex path="ad:position">
    <Join table="ad_address_ad_position" fromColumns="attr_gml_id" toColumns="parentfk" orderColumns="num" numbered="true"/>
    <Complex path="ad:GeographicPosition">
     <Complex path="ad:geometry">
       <Primitive path="@nilReason" mapping="ad_geographicposition_ad_geometry_attr_nilreason"/>
       <Primitive path="@gml:remoteSchema" mapping="ad_geographicposition_ad_geometry_attr_gml_remoteschema"/>
       <Primitive path="@owns" mapping="ad_geographicposition_ad_geometry_attr_owns"/>
       <Geometry path="." mapping="ad_geographicposition_ad_geometry_value"/>
     </Complex>
     [...]
     <Primitive path="ad:default" mapping="ad_geographicposition_ad_default"/>
   </Complex>
 </Complex>
 [...]
</FeatureTypeMapping>
----

In this example, property _gml:identifier_ is mapped as before (the
data values stem from table _ad_address_). In contrast to that,
property _ad:position_ can occur any number of times for a single
_ad_address_ feature instance. In order to reflect that in the
relational model, the values for this property have to be taken
from/stored in a separate table. The feature type table (_ad_address_)
must have a 1:n relation to this table.

The _<Join>_ element is used to define such a change in the table
context (in other words: a relation/join between two tables). A
_<Join>_ element may only occur as first child element of any of the
mapping elements (_<Primitive>_, _<Geometry>_, _<Feature>_ or
_<Complex>_). It changes from the current table context to another
one. In the example, the table context in the mapping of property
_ad:position_ is changed from _ad_address_ to
_ad_address_ad_position_. All mapping instructions that follow the
_<Join>_ element refer to the new table context. For example, the
geometry value is taken from
_ad_address_ad_position.ad_geographicposition_ad_geometry_value_.

The following table lists all available options for _<Join>_ elements:

[width="100%",cols="17%,9%,6%,68%",options="header",]
|===
|Option |Cardinality |Value |Description
|_table_ |1..1 |String |Name of the target table to change to.

|_fromColumns_ |1..1 |String |One or more columns that define the join
key in the source table.

|_toColumns_ |1..1 |String |One or more columns that define the join
key in the target table.

|_orderColumns_ |0..1 |String |One or more columns hat define the
order of the joined rows.

|_numbered_ |0..1 |Boolean |Set to true, if orderColumns refers to a
single column that contains natural numbers [1,2,3,...].

|_<AutoKeyColumn>_ |0..n |Complex |Columns in the target table that
store autogenerated keys (only required for transactions).
|===

Attributes _fromColumns_, _toColumns_ and _orderColumns_ may each
contain one or more columns. When specifying multiple columns, they must
be given as a whitespace-separated list. _orderColumns_ is used to
force a specific ordering on the joined table rows. If this attribute is
omitted, the order of joined rows is not defined and reconstructed
feature instances may vary each time they are fetched from the database.
In the above example, this would mean that the multiple _ad:position_
properties of an _ad:Address_ feature may change their order.

In case that the order column stores the child index of the XML element,
the _numbered_ attribute should be set to _true_. In this special
case, filtering on property names with child indexes will be correctly
mapped to SQL WHERE clauses as in the following WFS example request.

*SQL feature store: WFS query with child index*

[source,xml]
----
<GetFeature version="2.0.0" service="WFS">
  <Query typeNames="ad:Address">
    <fes:Filter>
      <fes:BBOX>
        <fes:ValueReference>ad:position[3]/ad:GeographicPosition/ad:geometry</fes:ValueReference>
        <gml:Envelope srsName="urn:ogc:def:crs:EPSG::4258">
          <gml:lowerCorner>52.691 5.244</gml:lowerCorner>
          <gml:upperCorner>52.711 5.245</gml:upperCorner>
        </gml:Envelope>
      </fes:BBOX>
    </fes:Filter>
  </Query>
</GetFeature>
----

In the above example, only those _ad:Address_ features will be
returned where the geometry in the third _ad:position_ property has an
intersection with the specified bounding box. If only other
_ad:position_ properties (e.g. the first one) matches this constraint,
they will not be included in the output.

The _<AutoKeyColumn>_ configuration option is only required when you
want to use transactions on your feature store and your relational model
is non-canonical. Ideally, the mapping will only change the table
context in case the feature type model allows for multiple child
elements at that point. In other words: if the XML schema has
_maxOccurs_ set to _unbounded_ for an element, the relational model
should have a corresponding 1:n relation. For a 1:n relation, the target
table of the context change should have a foreign key column that points
to the primary key column of the source table of the context change.
This is important, as the SQL feature store has to propagate keys from
the source table to the target table and store them there as well.

If the joined table is the origin of other joins, than it is important
that the SQL feature store can generate primary keys for the join table.
If not configured otherwise, it is assumed that column _id_ stores the
primary key and that the database will auto-generate values on insert
using database mechanisms such as sequences or triggers.

If this is not the case, use the _AutoKeyColumn_ options to define the
columns that make up the primary key in the join table and how the
values for these columns should be generated on insert. Here's an
example:

*SQL feature store: Key propagation for transactions*

[source,xml]
----
[...]
<Join table="B" fromColumns="id" toColumns="parentfk" orderColumns="num" numbered="true">
  <AutoKeyColumn name="pk1">
    <UUIDGenerator />
  </AutoKeyColumn>
  [...]
  <Join table="C" fromColumns="pk1" toColumns="parentfk" />
  [...]
</Join>
[...]
----

In this example snippet, the primary key for table _B_ is stored in
column _pk1_ and values for this column are generated using the UUID
generator. There's another change in the table context from B to C. Rows
in table C have a key stored in column _parentfk_ that corresponds to
the _B.pk1_. On insert, values generated for _B.pk1_ will be
propagated and stored for new rows in this table as well. The following
table lists the options for _<AutoKeyColumn>_ elements.

Inside a _<AutoKeyColumn>_, you may use the same key generators that
are available for feature id generation (see above).

[[anchor-null-handling]]
===== Handling of NULL values

By default, a _NULL_ value in a mapped database column means that just
the mapped particle is omitted from the reconstructed feature. However,
if the corresponding element/attribute or text node is required
according to the GML application schema, this will lead to invalid
feature instances. In order to deal with this, the global option
_<NullEscalation>_ should be set to _true_ after the mapping
configuration has been finished.

*SQL feature store: Activating NULL value escalation*

[source,xml]
----
[...]
<NullEscalation>true</NullEscalation>
[...]
----

If this option is turned on and a _NULL_ value is found in a mapped
column, the following strategy is applied:

* If the corresponding particle is not required according to the GML
application schema, just this particle is omitted.
* If the container element of the particle is nillable according to the
GML application schema, the _xsi:nil_ attribute of the element is set
to _true_.
* In all other cases, the _NULL_ is escalated to the container element
using the same strategy (until the feature level has been reached).

This works well most of the times, but sometimes, it can be handy to
override this behaviour. For that, each _<Primitive>_, _<Complex>_,
_<Geometry>_ or _<Feature>_ configuration element supports the
optional attribute _nullEscalation_. The following config snippet
demonstrates a custom _NULL_ escalation for element
_gml:endPosition_. By default, the content of this element is
required, but by setting it to _false_, _NULL_ escalation can be
manually switched off for this very particle.

*SQL feature store: Customizing NULL value escalation*

[source,xml]
----
[...]
<Complex path="gml:TimePeriod">
  <Complex path="gml:beginPosition">
    <Primitive path="text()" mapping="begin_position"/>
  </Complex>
  <Complex path="gml:endPosition">
    <Primitive path="@indeterminatePosition" mapping="end_position_indeterminate_position"/>
    <Primitive path="text()" mapping="end_position" nullEscalation="false"/>
  </Complex>
</Complex>
[...]
----

The following values are supported for attribute _nullEscalation_ on
_<Primitive>_, _<Complex>_, _<Geometry>_ or _<Feature>_
elements:

* _auto_: Handling of NULL values is derived from the GML application
schema. Same as omitting the _nullEscalation_ attribute.
* _true_: _NULL_ values are escalated to the container element.
* _false_: _NULL_ values are not escalated to the container element.

[[anchor-blob-mode]]
===== BLOB mapping

An alternative approach to mapping each feature type from an application
schema using _<FeatureTypeMapping>_ is to specify a single
_<BLOBMapping>_ element. This activates a different storage strategy
based on a fixed database schema. Central to this schema is a table that
stores every feature instance (and all of it's properties) as a BLOB
(binary large object).

Here is an overview on all options for _<BLOBMapping>_ elements:

[width="100%",cols="22%,10%,7%,61%",options="header",]
|===
|Option |Cardinality |Value |Description
|_<BlobTable>_ |0..1 |String |Database table that stores features,
default: _gml_objects_

|_<FeatureTypeTable>_ |0..1 |String |Database table that stores
feature types, default: _feature_types_
|===

The central table (controlled by _<BlobTable>_) uses the following
columns:

[width="100%",cols="19%,15%,66%",options="header",]
|===
|Column |PostGIS type |Used for
|_id_ |serial |Primary key

|_gml_id_ |text |Feature identifier (used for id queries and resolving
xlink references)

|_gml_bounded_by_ |geometry |Bounding box (used for spatial queries)

|_ft_type_ |smallint |Feature type identifier (used to narrow the
result set)

|_binary_object_ |bytea |Encoded feature instance
|===

The other table (controlled by _<FeatureTypeTable>_) stores a mapping
of feature type names to feature type identifiers:

[width="100%",cols="13%,16%,71%",options="header",]
|===
|Column |PostGIS type |Used for
|_id_ |smallint |Primary key

|_qname_ |text |Name of the feature type

|_bbox_ |geometry |Aggregated bounding box for all features of this
type
|===

NOTE: In order for _<BLOBMapping>_ to work, you need to have the correct
tables in your database and initialize the feature type table with the
names of all feature types you want to use. We recommend not to do this
manually, see <<anchor-mapping-wizard>>. The wizard will also create
suitable indexes to speed up queries.

NOTE: You may wonder how to get data into the database in BLOB mode. As for
standard mapping, you can do this by executing WFS-T requests or by
using the feature store loader. Its usage is described in the last steps
of <<anchor-mapping-wizard>>.

NOTE: In BLOB mode, only spatial and feature id queries can be mapped to SQL
WHERE-constraints. All other kinds of filter conditions are performed in
memory. See <<anchor-filtering>> for more information.

==== Transactions and feature id generation

The mapping defined by a _<FeatureTypeMapping>_ element generally
works in both directions:

* *Table-to-feature-type (query)*: Feature instances are created from
table rows
* *Feature-type-to-table (insert)*: New table rows are created for
inserted feature instances

However, there's a caveat for inserts: The SQL feature store has to know
how to obtain new and unique feature ids.

When features are inserted into a SQL feature store (for example via a
WFS transaction), the client can choose between different id generation
modes. These modes control whether feature ids (the values in the gml:id
attribute) have to be re-generated. There are three id generation modes
available, which directly relate to the WFS 1.1.0 specification:

* _UseExisting_: The feature store will use the original gml:id values
that have been provided in the input. This may lead to errors if the
provided ids are already in use or if the format of the id does not
match the configuration.
* _GenerateNew_: The feature store will discard the original gml:id
values and use the configured generator to produce new and unique
identifiers. References in the input (xlink:href) that point to a
feature with an reassigned id are fixed as well, so reference
consistency is ensured.
* _ReplaceDuplicate_: The feature store will try to use the original
gml:id values that have been provided in the input. If a certain
identifier already exists in the database, the configured generator is
used to produce a new and unique identifier. NOTE: Support for this mode
is not implemented yet.

NOTE: In a WFS 1.1.0 insert request, the id generation mode is controlled by
attribute _idGenMode_. WFS 1.0.0 and WFS 2.0.0 don't support to
specify it on a request basis. However, in the deegree WFS configuration
you can control it in the option _EnableTransactions_.

In order to generate the required ids for _GenerateNew_, you can
choose between different generators. These are configured in the
_<FIDMapping>_ child element of _<FeatureTypeMapping>_:

===== Auto id generator

The auto id generator depends on the database to provide new values for
the feature id column(s) on insert. This requires that the used feature
id columns are configured appropriately in the database (e.g. that they
have a trigger or a suitable column type such as _SERIAL_ in
PostgreSQL).

*SQL feature store: Auto id generator example*

[source,xml]
----
[...]
<FIDMapping prefix="AD_ADDRESS_">
  <Column name="attr_gml_id" />
  <AutoIDGenerator />
</FIDMapping>
[...]
----

This snippet defines the feature id mapping and the id generation
behaviour for a feature type called _ad:Address_

* When querying, the prefix _AD_ADDRESS__ is prepended to column
_attr_gml_id_ to create the exported feature id. If _attr_gml_id_
contains the value _42_ in the database, the feature instance that is
created from this row will have the value _AD_ADDRESS_42_.
* On insert (mode=UseExisting), provided gml:id values must have the
format _AD_ADDRESS_$_. The prefix _AD_ADDRESS__ is removed and the
remaining part of the identifier is stored in column _attr_gml_id_.
* On insert (mode=GenerateNew), the database must automatically create a
new value for column _attr_gml_id_ which will be the postfix of the
newly assigned feature id.

===== UUID generator

The UUID generator generator uses Java's UUID implementation to generate
new and unique identifiers. This requires that the database column for
the id is a character column that can store strings with a length of 36
characters and that the database does not perform any kind of insertion
value generation for this column (e.g triggers).

*SQL feature store: UUID generator example*

[source,xml]
----
[...]
<FIDMapping prefix="AD_ADDRESS_">
  <Column name="attr_gml_id" />
  <UUIDGenerator />
</FIDMapping>
[...]
----

This snippet defines the feature id mapping and the id generation
behaviour for a feature type called _ad:Address_

* When querying, the prefix _AD_ADDRESS__ is prepended to column
_attr_gml_id_ to create the exported feature id. If _attr_gml_id_
contains the value _550e8400-e29b-11d4-a716-446655440000_ in the
database, the feature instance that is created from this row will have
the value _AD_ADDRESS_550e8400-e29b-11d4-a716-446655440000_.
* On insert (mode=UseExisting), provided gml:id values must have the
format _AD_ADDRESS_$_. The prefix _AD_ADDRESS__ is removed and the
remaining part of the identifier is stored in column _attr_gml_id_.
* On insert (mode=GenerateNew), a new UUID is generated and stored in
column _attr_gml_id_.

===== Sequence id generator

The sequence id generator queries a database sequence to generate new
and unique identifiers. This requires that the database column for the
id is compatible with the values generated by the sequence and that the
database does not perform any kind of automatical value insertion for
this column (e.g triggers).

*SQL feature store: Database sequence generator example*

[source,xml]
----
[...]
<FIDMapping prefix="AD_ADDRESS_">
  <Column name="attr_gml_id" />
  <SequenceIDGenerator sequence="SEQ_FID">
</FIDMapping>
[...]
----

This snippet defines the feature id mapping and the id generation
behaviour for a feature type called _ad:Address_

* When querying, the prefix _AD_ADDRESS__ is prepended to column
_attr_gml_id_ to create the exported feature id. If _attr_gml_id_
contains the value _42_ in the database, the feature instance that is
created from this row will have the value _AD_ADDRESS_42_.
* On insert (mode=UseExisting), provided gml:id values must have the
format _AD_ADDRESS_$_. The prefix _AD_ADDRESS__ is removed and the
remaining part of the identifier is stored in column _attr_gml_id_.
* On insert (mode=GenerateNew), the database sequence _SEQ_FID_ is
queried for new values to be stored in column _attr_gml_id_.

[[anchor-filtering]]
==== Evaluation of query filters

The SQL feature store always tries to map filter conditions (e.g. from
WFS _GetFeature_ requests or when accessed by the WMS) to SQL-WHERE
conditions. However, this is not possible in all cases. Sometimes a
filter uses an expression that does not have an equivalent SQL-WHERE
clause. For example when using <<anchor-blob-mode>> and the filter is
not based on a feature id or a spatial constraint.

In such cases, the SQL feature store falls back to in-memory filtering.
It will reconstruct feature by feature from the database and evaluate
the filter in memory. If the filter matches, it will be included in the
result feature stream. If not, it is skipped.

The downside of this strategy is that it can put a serious load on your
server. If you want to turn off in-memory filtering completely, use
_<DisablePostFiltering>_. If this option is specified and a filter
requires in-memory filtering, the query will be rejected.

[[anchor-mapping-wizard]]
==== Auto-generating a mapping configuration and tables

Although this functionality is still in beta stage, the services console
can be used to automatically derive an SQL feature store configuration
and set up tables from an existing GML application schema. If you don't
have an existing database structure that you want to use, you can use
this option to create a working database set up very quickly. And even
if you have an existing database you need to map manually, this
functionality can be prove very helpful to generate a valid mapping
configuration to start with.

NOTE: As every (optional) attribute and element will be considered in the
mapping, you may easily end up with hundreds of tables or columns.

This walkthrough is based on the INSPIRE Annex I schemas, but you should
be able to use these instructions with other GML application schemas as
well. Make sure that the INSPIRE workspace has been downloaded and
activated as described in <<anchor-workspace-inspire>>. As another
prerequisite, you will have to create an empty, spatially-enabled
PostGIS database that you can connect to from your deegree installation.

TIP: Instead of PostGIS, you can also use an Oracle Spatial or an Microsoft
SQL Server database. In order to enable support for these databases, see
<<anchor-db-libraries>>.

NOTE: If the application schema contains UTF-8 characters which are not part
of the 7-bit ASCII subset they are normalised during the generation of
the feature store configuration for the database mapping (but kept for
the feature type names). So the mapping to table and column names
contains only 7-bit ASCII character and it is no requirement to the
database to use UTF-8.

As a first step, create a JDBC connection to your database. Click
*server connections -> jdbc* and enter *inspire* (or an other
identifier) as connection id:

.Creating a JDBC connection
image::console_featurestore_mapping1.jpg[Creating a JDBC connection,scaledwidth=50.0%]

Afterwards, click *Create new* and enter the connection details to your
database:

.Creating a JDBC connection
image::console_featurestore_mapping2.jpg[Creating a JDBC connection,scaledwidth=50.0%]

By clicking *Test connection*, you can ensure that deegree can connect
to your database:

.Testing the JDBC connection
image::console_featurestore_mapping3.jpg[Testing the JDBC connection,scaledwidth=50.0%]

If everything works, click *Create* to finish the creation of your JDBC
resource:

.Testing the JDBC connection
image::console_featurestore_mapping4.jpg[Testing the JDBC connection,scaledwidth=50.0%]

Now, change to *data stores -> feature*. We will have to delete the
existing (memory-based) feature store first. Click *Delete*:

.Deleting the memory-based feature store
image::console_featurestore_mapping5.jpg[Deleting the memory-based feature store,scaledwidth=50.0%]

Enter "inspire" as name for the new feature store, select "SQL" from the
drop-down box and click *Create new*:

.Creating a new SQL feature store resource
image::console_featurestore_mapping6.jpg[Creating a new SQL feature store resource,scaledwidth=50.0%]

Select "Create tables from GML application schema" and click *Next*:

.Mapping a new SQL feature store configuration
image::console_featurestore_mapping7.jpg[Mapping a new SQL feature store configuration,scaledwidth=50.0%]

You can now select the GML application schema files to be used. For this
walkthrough, tick _Addresses.xsd_, _AdministrativeUnits.xsd_ and
_CadastralParcels.xsd_ (if you select all schema files, hundreds of
feature types from INPIRE Annex I will be mapped):

.Selecting the GML schema files to be considered
image::console_featurestore_mapping8.jpg[Selecting the GML schema files to be considered,scaledwidth=50.0%]

NOTE: This view presents any .xsd files that are located below the
*appschemas/* directory of your deegree workspace. If you want to map
any other GML application schema (such as GeoSciML or CityGML), place a
copy of the application schema files into the *appschemas/* directory
(using your favorite method, e.g. a file browser) and click *Rescan*.
You should now have the option to select the files of this application
schema in the services console view.

.Selecting the GML schema files to be considered
image::console_featurestore_mapping9.jpg[Selecting the GML schema files to be considered,scaledwidth=50.0%]

Scroll down and click *Next*.

.Selecting mapping type and storage CRS
image::console_featurestore_mapping10.jpg[Selecting mapping type and storage CRS,scaledwidth=50.0%]

You will be presented with a rough analysis of the feature types
contained in the selected GML application schema files. Select
"Relational" (you may also select BLOB if your prefer this kind of
storage) and enter "EPSG:4258" as storage CRS (this is the code for
ETRS89, the recommmended CRS for harmonized INSPIRE datasets). After
clicking *Next*, an SQL feature store configuration will be
automatically derived from the application schema:

.The auto-generated SQL feature store configuration
image::console_featurestore_mapping11.jpg[The auto-generated SQL feature store configuration,scaledwidth=50.0%]

Click *Save* to store this configuration:

.Auto-generated SQL statements for creating tables
image::console_featurestore_mapping12.jpg[Auto-generated SQL statements for creating tables,scaledwidth=50.0%]

Now, click *Create DB tables*. You will be presented with an
auto-generated SQL script for creating the required tables in the
database:

.Auto-generated SQL statements for creating tables
image::console_featurestore_mapping13.jpg[Auto-generated SQL statements for creating tables,scaledwidth=50.0%]

Click *Execute*. The SQL statements will now be executed against your
database and the tables will be created:

.Mapping finished
image::console_featurestore_mapping15.jpg[Mapping finished,scaledwidth=50.0%]

Click *Start feature store*:

.Finished
image::console_featurestore_mapping17.jpg[Finished,scaledwidth=50.0%]

Click *Reload* to force a reinitialization of the other workspace
resources. We're finished. Features access of the WFS and WMS uses your
database now. However, as your database is empty, the WMS will not
render anything and the WFS will not return any features when queried.
In order to insert some harmonized INSPIRE features, click *send
requests* and select one of the insert requests:

Use the third drop-down menu to select an example request. Entries
"Insert_200.xml" or "Insert_110.xml" can be used to insert a small
number of INSPIRE Address features using WFS-T insert requests:

.WFS-T example requests
image::console_workspace_inspire3.png[WFS-T example requests,scaledwidth=50.0%]

Click *Send* to execute the request. After successful insertion, the
database contains a few addresses, and you may want to move back to the
layer overview (*see layers*). If you activate the AD.Address layer, the
newly inserted features will be rendered by the deegree WMS (look for
them in the area of Enkhuizen):

.Ad.Address layer after insertion of example Address features
image::console_workspace_inspire4.png[Ad.Address layer after insertion of example Address features,scaledwidth=50.0%]

Of course, you can also perform WFS queries against the database
backend, such as requesting of INSPIRE Addresses by street name:

.More WFS examples
image::console_workspace_inspire5.png[More WFS examples,scaledwidth=50.0%]

Besides WFS-T requests, there's another handy option for inserting
GML-encoded features. Click *data stores -> feature* to access the
feature store view again:

.Accessing the feature store loader
image::console_featurestore_mapping18.jpg[Accessing the feature store loader,scaledwidth=50.0%]

After clicking *Loader*, you will be presented with a simple view where
you can insert a URL of a valid GML dataset:

.The feature store loader
image::console_featurestore_mapping19.jpg[The feature store loader,scaledwidth=50.0%]

Basically, you can use this view to insert any valid, GML-encoded
dataset, as long as it conforms to the application schema. The INSPIRE
workspace contains some suitable example datasets, so you may use a
file-URL like:

* file:/home/kelvin/.deegree/deegree-workspace-inspire/data/au-provincies.gml
* file:/home/kelvin/.deegree/deegree-workspace-inspire/data/au-gemeenten.gml
* file:/home/kelvin/.deegree/deegree-workspace-inspire/data/au-land.gml
* file:/home/kelvin/.deegree/deegree-workspace-inspire/data/cadastralparcels-limburg.xml
* file:/home/kelvin/.deegree/deegree-workspace-inspire/data/cadastralparcels-northholland.xml

TIP: The above URLs are for a UNIX system with a user named "kelvin". You
will need to adapt the URLs to match the location of your workspace
directory.

After entering the URL, click *Import*:

.Imported INSPIRE datasets via the Loader
image::console_featurestore_mapping20.jpg[Imported INSPIRE datasets via the Loader,scaledwidth=50.0%]
